// Code generated by scripts/gengraphql.go. DO NOT EDIT.

package schema

import (
	errors "errors"
	graphql1 "github.com/graphql-go/graphql"
	graphql "github.com/sensu/sensu-go/graphql"
	time "time"
)

// MetricType self descriptive
var MetricType = graphql.NewType("Metric", graphql.InterfaceKind)

// RegisterMetric registers Metric object type with given service.
func RegisterMetric(svc *graphql.Service, impl graphql.InterfaceTypeResolver) {
	svc.RegisterInterface(_InterfaceTypeMetricDesc, impl)
}
func _InterfaceTypeMetricConfigFn() graphql1.InterfaceConfig {
	return graphql1.InterfaceConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{
			"labels": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "labels",
				Type:              graphql1.NewNonNull(graphql1.NewList(graphql1.NewNonNull(graphql.OutputType("KVPairString")))),
			},
			"timestamp": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "timestamp",
				Type:              graphql1.DateTime,
			},
		},
		Name: "Metric",
		ResolveType: func(_ graphql1.ResolveTypeParams) *graphql1.Object {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see InterfaceTypeResolver.")
		},
	}
}

// describe Metric's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _InterfaceTypeMetricDesc = graphql.InterfaceDesc{Config: _InterfaceTypeMetricConfigFn}

// MetricKind self descriptive
type MetricKind string

// MetricKinds holds enum values
var MetricKinds = _EnumTypeMetricKindValues{
	COUNTER:   "COUNTER",
	GAUGE:     "GAUGE",
	HISTOGRAM: "HISTOGRAM",
	SUMMARY:   "SUMMARY",
	UNTYPED:   "UNTYPED",
}

// MetricKindType self descriptive
var MetricKindType = graphql.NewType("MetricKind", graphql.EnumKind)

// RegisterMetricKind registers MetricKind object type with given service.
func RegisterMetricKind(svc *graphql.Service) {
	svc.RegisterEnum(_EnumTypeMetricKindDesc)
}
func _EnumTypeMetricKindConfigFn() graphql1.EnumConfig {
	return graphql1.EnumConfig{
		Description: "self descriptive",
		Name:        "MetricKind",
		Values: graphql1.EnumValueConfigMap{
			"COUNTER": &graphql1.EnumValueConfig{
				DeprecationReason: "",
				Description:       "self descriptive",
				Value:             "COUNTER",
			},
			"GAUGE": &graphql1.EnumValueConfig{
				DeprecationReason: "",
				Description:       "self descriptive",
				Value:             "GAUGE",
			},
			"HISTOGRAM": &graphql1.EnumValueConfig{
				DeprecationReason: "",
				Description:       "self descriptive",
				Value:             "HISTOGRAM",
			},
			"SUMMARY": &graphql1.EnumValueConfig{
				DeprecationReason: "",
				Description:       "self descriptive",
				Value:             "SUMMARY",
			},
			"UNTYPED": &graphql1.EnumValueConfig{
				DeprecationReason: "",
				Description:       "self descriptive",
				Value:             "UNTYPED",
			},
		},
	}
}

// describe MetricKind's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _EnumTypeMetricKindDesc = graphql.EnumDesc{Config: _EnumTypeMetricKindConfigFn}

type _EnumTypeMetricKindValues struct {
	// COUNTER - self descriptive
	COUNTER MetricKind
	// GAUGE - self descriptive
	GAUGE MetricKind
	// SUMMARY - self descriptive
	SUMMARY MetricKind
	// UNTYPED - self descriptive
	UNTYPED MetricKind
	// HISTOGRAM - self descriptive
	HISTOGRAM MetricKind
}

// QuantileMetricQuantileFieldResolver implement to resolve requests for the QuantileMetric's quantile field.
type QuantileMetricQuantileFieldResolver interface {
	// Quantile implements response to request for quantile field.
	Quantile(p graphql.ResolveParams) (float64, error)
}

// QuantileMetricValueFieldResolver implement to resolve requests for the QuantileMetric's value field.
type QuantileMetricValueFieldResolver interface {
	// Value implements response to request for value field.
	Value(p graphql.ResolveParams) (float64, error)
}

//
// QuantileMetricFieldResolvers represents a collection of methods whose products represent the
// response values of the 'QuantileMetric' type.
//
// == Example SDL
//
//   """
//   Dog's are not hooman.
//   """
//   type Dog implements Pet {
//     "name of this fine beast."
//     name:  String!
//
//     "breed of this silly animal; probably shibe."
//     breed: [Breed]
//   }
//
// == Example generated interface
//
//   // DogResolver ...
//   type DogFieldResolvers interface {
//     DogNameFieldResolver
//     DogBreedFieldResolver
//
//     // IsTypeOf is used to determine if a given value is associated with the Dog type
//     IsTypeOf(interface{}, graphql.IsTypeOfParams) bool
//   }
//
// == Example implementation ...
//
//   // DogResolver implements DogFieldResolvers interface
//   type DogResolver struct {
//     logger logrus.LogEntry
//     store interface{
//       store.BreedStore
//       store.DogStore
//     }
//   }
//
//   // Name implements response to request for name field.
//   func (r *DogResolver) Name(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     return dog.GetName()
//   }
//
//   // Breed implements response to request for breed field.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     breed := r.store.GetBreed(dog.GetBreedName())
//     return breed
//   }
//
//   // IsTypeOf is used to determine if a given value is associated with the Dog type
//   func (r *DogResolver) IsTypeOf(p graphql.IsTypeOfParams) bool {
//     // ... implementation details ...
//     _, ok := p.Value.(DogGetter)
//     return ok
//   }
//
type QuantileMetricFieldResolvers interface {
	QuantileMetricQuantileFieldResolver
	QuantileMetricValueFieldResolver
}

// QuantileMetricAliases implements all methods on QuantileMetricFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
//
// == Example SDL
//
//    type Dog {
//      name:   String!
//      weight: Float!
//      dob:    DateTime
//      breed:  [Breed]
//    }
//
// == Example generated aliases
//
//   type DogAliases struct {}
//   func (_ DogAliases) Name(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Weight(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Dob(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//
// == Example Implementation
//
//   type DogResolver struct { // Implements DogResolver
//     DogAliases
//     store store.BreedStore
//   }
//
//   // NOTE:
//   // All other fields are satisified by DogAliases but since this one
//   // requires hitting the store we implement it in our resolver.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) interface{} {
//     dog := v.(*Dog)
//     return r.BreedsById(dog.BreedIDs)
//   }
//
type QuantileMetricAliases struct{}

// Quantile implements response to request for 'quantile' field.
func (_ QuantileMetricAliases) Quantile(p graphql.ResolveParams) (float64, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Float.ParseValue(val).(float64)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'quantile'")
	}
	return ret, err
}

// Value implements response to request for 'value' field.
func (_ QuantileMetricAliases) Value(p graphql.ResolveParams) (float64, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Float.ParseValue(val).(float64)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'value'")
	}
	return ret, err
}

// QuantileMetricType self descriptive
var QuantileMetricType = graphql.NewType("QuantileMetric", graphql.ObjectKind)

// RegisterQuantileMetric registers QuantileMetric object type with given service.
func RegisterQuantileMetric(svc *graphql.Service, impl QuantileMetricFieldResolvers) {
	svc.RegisterObject(_ObjectTypeQuantileMetricDesc, impl)
}
func _ObjTypeQuantileMetricQuantileHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(QuantileMetricQuantileFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Quantile(frp)
	}
}

func _ObjTypeQuantileMetricValueHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(QuantileMetricValueFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Value(frp)
	}
}

func _ObjectTypeQuantileMetricConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{
			"quantile": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "quantile",
				Type:              graphql1.Float,
			},
			"value": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "value",
				Type:              graphql1.Float,
			},
		},
		Interfaces: []*graphql1.Interface{},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see QuantileMetricFieldResolvers.")
		},
		Name: "QuantileMetric",
	}
}

// describe QuantileMetric's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeQuantileMetricDesc = graphql.ObjectDesc{
	Config: _ObjectTypeQuantileMetricConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{
		"quantile": _ObjTypeQuantileMetricQuantileHandler,
		"value":    _ObjTypeQuantileMetricValueHandler,
	},
}

// BucketMetricCumulativeCountFieldResolver implement to resolve requests for the BucketMetric's cumulativeCount field.
type BucketMetricCumulativeCountFieldResolver interface {
	// CumulativeCount implements response to request for cumulativeCount field.
	CumulativeCount(p graphql.ResolveParams) (int, error)
}

// BucketMetricUpperBoundFieldResolver implement to resolve requests for the BucketMetric's upperBound field.
type BucketMetricUpperBoundFieldResolver interface {
	// UpperBound implements response to request for upperBound field.
	UpperBound(p graphql.ResolveParams) (float64, error)
}

//
// BucketMetricFieldResolvers represents a collection of methods whose products represent the
// response values of the 'BucketMetric' type.
//
// == Example SDL
//
//   """
//   Dog's are not hooman.
//   """
//   type Dog implements Pet {
//     "name of this fine beast."
//     name:  String!
//
//     "breed of this silly animal; probably shibe."
//     breed: [Breed]
//   }
//
// == Example generated interface
//
//   // DogResolver ...
//   type DogFieldResolvers interface {
//     DogNameFieldResolver
//     DogBreedFieldResolver
//
//     // IsTypeOf is used to determine if a given value is associated with the Dog type
//     IsTypeOf(interface{}, graphql.IsTypeOfParams) bool
//   }
//
// == Example implementation ...
//
//   // DogResolver implements DogFieldResolvers interface
//   type DogResolver struct {
//     logger logrus.LogEntry
//     store interface{
//       store.BreedStore
//       store.DogStore
//     }
//   }
//
//   // Name implements response to request for name field.
//   func (r *DogResolver) Name(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     return dog.GetName()
//   }
//
//   // Breed implements response to request for breed field.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     breed := r.store.GetBreed(dog.GetBreedName())
//     return breed
//   }
//
//   // IsTypeOf is used to determine if a given value is associated with the Dog type
//   func (r *DogResolver) IsTypeOf(p graphql.IsTypeOfParams) bool {
//     // ... implementation details ...
//     _, ok := p.Value.(DogGetter)
//     return ok
//   }
//
type BucketMetricFieldResolvers interface {
	BucketMetricCumulativeCountFieldResolver
	BucketMetricUpperBoundFieldResolver
}

// BucketMetricAliases implements all methods on BucketMetricFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
//
// == Example SDL
//
//    type Dog {
//      name:   String!
//      weight: Float!
//      dob:    DateTime
//      breed:  [Breed]
//    }
//
// == Example generated aliases
//
//   type DogAliases struct {}
//   func (_ DogAliases) Name(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Weight(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Dob(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//
// == Example Implementation
//
//   type DogResolver struct { // Implements DogResolver
//     DogAliases
//     store store.BreedStore
//   }
//
//   // NOTE:
//   // All other fields are satisified by DogAliases but since this one
//   // requires hitting the store we implement it in our resolver.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) interface{} {
//     dog := v.(*Dog)
//     return r.BreedsById(dog.BreedIDs)
//   }
//
type BucketMetricAliases struct{}

// CumulativeCount implements response to request for 'cumulativeCount' field.
func (_ BucketMetricAliases) CumulativeCount(p graphql.ResolveParams) (int, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Int.ParseValue(val).(int)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'cumulativeCount'")
	}
	return ret, err
}

// UpperBound implements response to request for 'upperBound' field.
func (_ BucketMetricAliases) UpperBound(p graphql.ResolveParams) (float64, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Float.ParseValue(val).(float64)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'upperBound'")
	}
	return ret, err
}

// BucketMetricType self descriptive
var BucketMetricType = graphql.NewType("BucketMetric", graphql.ObjectKind)

// RegisterBucketMetric registers BucketMetric object type with given service.
func RegisterBucketMetric(svc *graphql.Service, impl BucketMetricFieldResolvers) {
	svc.RegisterObject(_ObjectTypeBucketMetricDesc, impl)
}
func _ObjTypeBucketMetricCumulativeCountHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(BucketMetricCumulativeCountFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.CumulativeCount(frp)
	}
}

func _ObjTypeBucketMetricUpperBoundHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(BucketMetricUpperBoundFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.UpperBound(frp)
	}
}

func _ObjectTypeBucketMetricConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{
			"cumulativeCount": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "cumulativeCount",
				Type:              graphql1.Int,
			},
			"upperBound": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "upperBound",
				Type:              graphql1.Float,
			},
		},
		Interfaces: []*graphql1.Interface{},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see BucketMetricFieldResolvers.")
		},
		Name: "BucketMetric",
	}
}

// describe BucketMetric's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeBucketMetricDesc = graphql.ObjectDesc{
	Config: _ObjectTypeBucketMetricConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{
		"cumulativeCount": _ObjTypeBucketMetricCumulativeCountHandler,
		"upperBound":      _ObjTypeBucketMetricUpperBoundHandler,
	},
}

// CounterMetricLabelsFieldResolver implement to resolve requests for the CounterMetric's labels field.
type CounterMetricLabelsFieldResolver interface {
	// Labels implements response to request for labels field.
	Labels(p graphql.ResolveParams) (interface{}, error)
}

// CounterMetricTimestampFieldResolver implement to resolve requests for the CounterMetric's timestamp field.
type CounterMetricTimestampFieldResolver interface {
	// Timestamp implements response to request for timestamp field.
	Timestamp(p graphql.ResolveParams) (*time.Time, error)
}

// CounterMetricValueFieldResolver implement to resolve requests for the CounterMetric's value field.
type CounterMetricValueFieldResolver interface {
	// Value implements response to request for value field.
	Value(p graphql.ResolveParams) (float64, error)
}

//
// CounterMetricFieldResolvers represents a collection of methods whose products represent the
// response values of the 'CounterMetric' type.
//
// == Example SDL
//
//   """
//   Dog's are not hooman.
//   """
//   type Dog implements Pet {
//     "name of this fine beast."
//     name:  String!
//
//     "breed of this silly animal; probably shibe."
//     breed: [Breed]
//   }
//
// == Example generated interface
//
//   // DogResolver ...
//   type DogFieldResolvers interface {
//     DogNameFieldResolver
//     DogBreedFieldResolver
//
//     // IsTypeOf is used to determine if a given value is associated with the Dog type
//     IsTypeOf(interface{}, graphql.IsTypeOfParams) bool
//   }
//
// == Example implementation ...
//
//   // DogResolver implements DogFieldResolvers interface
//   type DogResolver struct {
//     logger logrus.LogEntry
//     store interface{
//       store.BreedStore
//       store.DogStore
//     }
//   }
//
//   // Name implements response to request for name field.
//   func (r *DogResolver) Name(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     return dog.GetName()
//   }
//
//   // Breed implements response to request for breed field.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     breed := r.store.GetBreed(dog.GetBreedName())
//     return breed
//   }
//
//   // IsTypeOf is used to determine if a given value is associated with the Dog type
//   func (r *DogResolver) IsTypeOf(p graphql.IsTypeOfParams) bool {
//     // ... implementation details ...
//     _, ok := p.Value.(DogGetter)
//     return ok
//   }
//
type CounterMetricFieldResolvers interface {
	CounterMetricLabelsFieldResolver
	CounterMetricTimestampFieldResolver
	CounterMetricValueFieldResolver
}

// CounterMetricAliases implements all methods on CounterMetricFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
//
// == Example SDL
//
//    type Dog {
//      name:   String!
//      weight: Float!
//      dob:    DateTime
//      breed:  [Breed]
//    }
//
// == Example generated aliases
//
//   type DogAliases struct {}
//   func (_ DogAliases) Name(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Weight(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Dob(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//
// == Example Implementation
//
//   type DogResolver struct { // Implements DogResolver
//     DogAliases
//     store store.BreedStore
//   }
//
//   // NOTE:
//   // All other fields are satisified by DogAliases but since this one
//   // requires hitting the store we implement it in our resolver.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) interface{} {
//     dog := v.(*Dog)
//     return r.BreedsById(dog.BreedIDs)
//   }
//
type CounterMetricAliases struct{}

// Labels implements response to request for 'labels' field.
func (_ CounterMetricAliases) Labels(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	return val, err
}

// Timestamp implements response to request for 'timestamp' field.
func (_ CounterMetricAliases) Timestamp(p graphql.ResolveParams) (*time.Time, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := val.(*time.Time)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'timestamp'")
	}
	return ret, err
}

// Value implements response to request for 'value' field.
func (_ CounterMetricAliases) Value(p graphql.ResolveParams) (float64, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Float.ParseValue(val).(float64)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'value'")
	}
	return ret, err
}

// CounterMetricType self descriptive
var CounterMetricType = graphql.NewType("CounterMetric", graphql.ObjectKind)

// RegisterCounterMetric registers CounterMetric object type with given service.
func RegisterCounterMetric(svc *graphql.Service, impl CounterMetricFieldResolvers) {
	svc.RegisterObject(_ObjectTypeCounterMetricDesc, impl)
}
func _ObjTypeCounterMetricLabelsHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(CounterMetricLabelsFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Labels(frp)
	}
}

func _ObjTypeCounterMetricTimestampHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(CounterMetricTimestampFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Timestamp(frp)
	}
}

func _ObjTypeCounterMetricValueHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(CounterMetricValueFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Value(frp)
	}
}

func _ObjectTypeCounterMetricConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{
			"labels": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "labels",
				Type:              graphql1.NewNonNull(graphql1.NewList(graphql1.NewNonNull(graphql.OutputType("KVPairString")))),
			},
			"timestamp": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "timestamp",
				Type:              graphql1.DateTime,
			},
			"value": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "value",
				Type:              graphql1.Float,
			},
		},
		Interfaces: []*graphql1.Interface{
			graphql.Interface("Metric")},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see CounterMetricFieldResolvers.")
		},
		Name: "CounterMetric",
	}
}

// describe CounterMetric's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeCounterMetricDesc = graphql.ObjectDesc{
	Config: _ObjectTypeCounterMetricConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{
		"labels":    _ObjTypeCounterMetricLabelsHandler,
		"timestamp": _ObjTypeCounterMetricTimestampHandler,
		"value":     _ObjTypeCounterMetricValueHandler,
	},
}

// GaugeMetricLabelsFieldResolver implement to resolve requests for the GaugeMetric's labels field.
type GaugeMetricLabelsFieldResolver interface {
	// Labels implements response to request for labels field.
	Labels(p graphql.ResolveParams) (interface{}, error)
}

// GaugeMetricTimestampFieldResolver implement to resolve requests for the GaugeMetric's timestamp field.
type GaugeMetricTimestampFieldResolver interface {
	// Timestamp implements response to request for timestamp field.
	Timestamp(p graphql.ResolveParams) (*time.Time, error)
}

// GaugeMetricValueFieldResolver implement to resolve requests for the GaugeMetric's value field.
type GaugeMetricValueFieldResolver interface {
	// Value implements response to request for value field.
	Value(p graphql.ResolveParams) (float64, error)
}

//
// GaugeMetricFieldResolvers represents a collection of methods whose products represent the
// response values of the 'GaugeMetric' type.
//
// == Example SDL
//
//   """
//   Dog's are not hooman.
//   """
//   type Dog implements Pet {
//     "name of this fine beast."
//     name:  String!
//
//     "breed of this silly animal; probably shibe."
//     breed: [Breed]
//   }
//
// == Example generated interface
//
//   // DogResolver ...
//   type DogFieldResolvers interface {
//     DogNameFieldResolver
//     DogBreedFieldResolver
//
//     // IsTypeOf is used to determine if a given value is associated with the Dog type
//     IsTypeOf(interface{}, graphql.IsTypeOfParams) bool
//   }
//
// == Example implementation ...
//
//   // DogResolver implements DogFieldResolvers interface
//   type DogResolver struct {
//     logger logrus.LogEntry
//     store interface{
//       store.BreedStore
//       store.DogStore
//     }
//   }
//
//   // Name implements response to request for name field.
//   func (r *DogResolver) Name(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     return dog.GetName()
//   }
//
//   // Breed implements response to request for breed field.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     breed := r.store.GetBreed(dog.GetBreedName())
//     return breed
//   }
//
//   // IsTypeOf is used to determine if a given value is associated with the Dog type
//   func (r *DogResolver) IsTypeOf(p graphql.IsTypeOfParams) bool {
//     // ... implementation details ...
//     _, ok := p.Value.(DogGetter)
//     return ok
//   }
//
type GaugeMetricFieldResolvers interface {
	GaugeMetricLabelsFieldResolver
	GaugeMetricTimestampFieldResolver
	GaugeMetricValueFieldResolver
}

// GaugeMetricAliases implements all methods on GaugeMetricFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
//
// == Example SDL
//
//    type Dog {
//      name:   String!
//      weight: Float!
//      dob:    DateTime
//      breed:  [Breed]
//    }
//
// == Example generated aliases
//
//   type DogAliases struct {}
//   func (_ DogAliases) Name(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Weight(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Dob(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//
// == Example Implementation
//
//   type DogResolver struct { // Implements DogResolver
//     DogAliases
//     store store.BreedStore
//   }
//
//   // NOTE:
//   // All other fields are satisified by DogAliases but since this one
//   // requires hitting the store we implement it in our resolver.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) interface{} {
//     dog := v.(*Dog)
//     return r.BreedsById(dog.BreedIDs)
//   }
//
type GaugeMetricAliases struct{}

// Labels implements response to request for 'labels' field.
func (_ GaugeMetricAliases) Labels(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	return val, err
}

// Timestamp implements response to request for 'timestamp' field.
func (_ GaugeMetricAliases) Timestamp(p graphql.ResolveParams) (*time.Time, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := val.(*time.Time)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'timestamp'")
	}
	return ret, err
}

// Value implements response to request for 'value' field.
func (_ GaugeMetricAliases) Value(p graphql.ResolveParams) (float64, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Float.ParseValue(val).(float64)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'value'")
	}
	return ret, err
}

// GaugeMetricType self descriptive
var GaugeMetricType = graphql.NewType("GaugeMetric", graphql.ObjectKind)

// RegisterGaugeMetric registers GaugeMetric object type with given service.
func RegisterGaugeMetric(svc *graphql.Service, impl GaugeMetricFieldResolvers) {
	svc.RegisterObject(_ObjectTypeGaugeMetricDesc, impl)
}
func _ObjTypeGaugeMetricLabelsHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(GaugeMetricLabelsFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Labels(frp)
	}
}

func _ObjTypeGaugeMetricTimestampHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(GaugeMetricTimestampFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Timestamp(frp)
	}
}

func _ObjTypeGaugeMetricValueHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(GaugeMetricValueFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Value(frp)
	}
}

func _ObjectTypeGaugeMetricConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{
			"labels": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "labels",
				Type:              graphql1.NewNonNull(graphql1.NewList(graphql1.NewNonNull(graphql.OutputType("KVPairString")))),
			},
			"timestamp": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "timestamp",
				Type:              graphql1.DateTime,
			},
			"value": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "value",
				Type:              graphql1.Float,
			},
		},
		Interfaces: []*graphql1.Interface{
			graphql.Interface("Metric")},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see GaugeMetricFieldResolvers.")
		},
		Name: "GaugeMetric",
	}
}

// describe GaugeMetric's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeGaugeMetricDesc = graphql.ObjectDesc{
	Config: _ObjectTypeGaugeMetricConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{
		"labels":    _ObjTypeGaugeMetricLabelsHandler,
		"timestamp": _ObjTypeGaugeMetricTimestampHandler,
		"value":     _ObjTypeGaugeMetricValueHandler,
	},
}

// SummaryMetricLabelsFieldResolver implement to resolve requests for the SummaryMetric's labels field.
type SummaryMetricLabelsFieldResolver interface {
	// Labels implements response to request for labels field.
	Labels(p graphql.ResolveParams) (interface{}, error)
}

// SummaryMetricTimestampFieldResolver implement to resolve requests for the SummaryMetric's timestamp field.
type SummaryMetricTimestampFieldResolver interface {
	// Timestamp implements response to request for timestamp field.
	Timestamp(p graphql.ResolveParams) (*time.Time, error)
}

// SummaryMetricSampleCountFieldResolver implement to resolve requests for the SummaryMetric's sampleCount field.
type SummaryMetricSampleCountFieldResolver interface {
	// SampleCount implements response to request for sampleCount field.
	SampleCount(p graphql.ResolveParams) (int, error)
}

// SummaryMetricSampleSumFieldResolver implement to resolve requests for the SummaryMetric's sampleSum field.
type SummaryMetricSampleSumFieldResolver interface {
	// SampleSum implements response to request for sampleSum field.
	SampleSum(p graphql.ResolveParams) (float64, error)
}

// SummaryMetricQuantileFieldResolver implement to resolve requests for the SummaryMetric's quantile field.
type SummaryMetricQuantileFieldResolver interface {
	// Quantile implements response to request for quantile field.
	Quantile(p graphql.ResolveParams) (interface{}, error)
}

//
// SummaryMetricFieldResolvers represents a collection of methods whose products represent the
// response values of the 'SummaryMetric' type.
//
// == Example SDL
//
//   """
//   Dog's are not hooman.
//   """
//   type Dog implements Pet {
//     "name of this fine beast."
//     name:  String!
//
//     "breed of this silly animal; probably shibe."
//     breed: [Breed]
//   }
//
// == Example generated interface
//
//   // DogResolver ...
//   type DogFieldResolvers interface {
//     DogNameFieldResolver
//     DogBreedFieldResolver
//
//     // IsTypeOf is used to determine if a given value is associated with the Dog type
//     IsTypeOf(interface{}, graphql.IsTypeOfParams) bool
//   }
//
// == Example implementation ...
//
//   // DogResolver implements DogFieldResolvers interface
//   type DogResolver struct {
//     logger logrus.LogEntry
//     store interface{
//       store.BreedStore
//       store.DogStore
//     }
//   }
//
//   // Name implements response to request for name field.
//   func (r *DogResolver) Name(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     return dog.GetName()
//   }
//
//   // Breed implements response to request for breed field.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     breed := r.store.GetBreed(dog.GetBreedName())
//     return breed
//   }
//
//   // IsTypeOf is used to determine if a given value is associated with the Dog type
//   func (r *DogResolver) IsTypeOf(p graphql.IsTypeOfParams) bool {
//     // ... implementation details ...
//     _, ok := p.Value.(DogGetter)
//     return ok
//   }
//
type SummaryMetricFieldResolvers interface {
	SummaryMetricLabelsFieldResolver
	SummaryMetricTimestampFieldResolver
	SummaryMetricSampleCountFieldResolver
	SummaryMetricSampleSumFieldResolver
	SummaryMetricQuantileFieldResolver
}

// SummaryMetricAliases implements all methods on SummaryMetricFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
//
// == Example SDL
//
//    type Dog {
//      name:   String!
//      weight: Float!
//      dob:    DateTime
//      breed:  [Breed]
//    }
//
// == Example generated aliases
//
//   type DogAliases struct {}
//   func (_ DogAliases) Name(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Weight(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Dob(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//
// == Example Implementation
//
//   type DogResolver struct { // Implements DogResolver
//     DogAliases
//     store store.BreedStore
//   }
//
//   // NOTE:
//   // All other fields are satisified by DogAliases but since this one
//   // requires hitting the store we implement it in our resolver.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) interface{} {
//     dog := v.(*Dog)
//     return r.BreedsById(dog.BreedIDs)
//   }
//
type SummaryMetricAliases struct{}

// Labels implements response to request for 'labels' field.
func (_ SummaryMetricAliases) Labels(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	return val, err
}

// Timestamp implements response to request for 'timestamp' field.
func (_ SummaryMetricAliases) Timestamp(p graphql.ResolveParams) (*time.Time, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := val.(*time.Time)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'timestamp'")
	}
	return ret, err
}

// SampleCount implements response to request for 'sampleCount' field.
func (_ SummaryMetricAliases) SampleCount(p graphql.ResolveParams) (int, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Int.ParseValue(val).(int)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'sampleCount'")
	}
	return ret, err
}

// SampleSum implements response to request for 'sampleSum' field.
func (_ SummaryMetricAliases) SampleSum(p graphql.ResolveParams) (float64, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Float.ParseValue(val).(float64)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'sampleSum'")
	}
	return ret, err
}

// Quantile implements response to request for 'quantile' field.
func (_ SummaryMetricAliases) Quantile(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	return val, err
}

// SummaryMetricType self descriptive
var SummaryMetricType = graphql.NewType("SummaryMetric", graphql.ObjectKind)

// RegisterSummaryMetric registers SummaryMetric object type with given service.
func RegisterSummaryMetric(svc *graphql.Service, impl SummaryMetricFieldResolvers) {
	svc.RegisterObject(_ObjectTypeSummaryMetricDesc, impl)
}
func _ObjTypeSummaryMetricLabelsHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(SummaryMetricLabelsFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Labels(frp)
	}
}

func _ObjTypeSummaryMetricTimestampHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(SummaryMetricTimestampFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Timestamp(frp)
	}
}

func _ObjTypeSummaryMetricSampleCountHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(SummaryMetricSampleCountFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.SampleCount(frp)
	}
}

func _ObjTypeSummaryMetricSampleSumHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(SummaryMetricSampleSumFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.SampleSum(frp)
	}
}

func _ObjTypeSummaryMetricQuantileHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(SummaryMetricQuantileFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Quantile(frp)
	}
}

func _ObjectTypeSummaryMetricConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{
			"labels": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "labels",
				Type:              graphql1.NewNonNull(graphql1.NewList(graphql1.NewNonNull(graphql.OutputType("KVPairString")))),
			},
			"quantile": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "quantile",
				Type:              graphql1.NewNonNull(graphql1.NewList(graphql.OutputType("QuantileMetric"))),
			},
			"sampleCount": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "sampleCount",
				Type:              graphql1.Int,
			},
			"sampleSum": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "sampleSum",
				Type:              graphql1.Float,
			},
			"timestamp": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "timestamp",
				Type:              graphql1.DateTime,
			},
		},
		Interfaces: []*graphql1.Interface{
			graphql.Interface("Metric")},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see SummaryMetricFieldResolvers.")
		},
		Name: "SummaryMetric",
	}
}

// describe SummaryMetric's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeSummaryMetricDesc = graphql.ObjectDesc{
	Config: _ObjectTypeSummaryMetricConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{
		"labels":      _ObjTypeSummaryMetricLabelsHandler,
		"quantile":    _ObjTypeSummaryMetricQuantileHandler,
		"sampleCount": _ObjTypeSummaryMetricSampleCountHandler,
		"sampleSum":   _ObjTypeSummaryMetricSampleSumHandler,
		"timestamp":   _ObjTypeSummaryMetricTimestampHandler,
	},
}

// UntypedMetricLabelsFieldResolver implement to resolve requests for the UntypedMetric's labels field.
type UntypedMetricLabelsFieldResolver interface {
	// Labels implements response to request for labels field.
	Labels(p graphql.ResolveParams) (interface{}, error)
}

// UntypedMetricTimestampFieldResolver implement to resolve requests for the UntypedMetric's timestamp field.
type UntypedMetricTimestampFieldResolver interface {
	// Timestamp implements response to request for timestamp field.
	Timestamp(p graphql.ResolveParams) (*time.Time, error)
}

// UntypedMetricValueFieldResolver implement to resolve requests for the UntypedMetric's value field.
type UntypedMetricValueFieldResolver interface {
	// Value implements response to request for value field.
	Value(p graphql.ResolveParams) (float64, error)
}

//
// UntypedMetricFieldResolvers represents a collection of methods whose products represent the
// response values of the 'UntypedMetric' type.
//
// == Example SDL
//
//   """
//   Dog's are not hooman.
//   """
//   type Dog implements Pet {
//     "name of this fine beast."
//     name:  String!
//
//     "breed of this silly animal; probably shibe."
//     breed: [Breed]
//   }
//
// == Example generated interface
//
//   // DogResolver ...
//   type DogFieldResolvers interface {
//     DogNameFieldResolver
//     DogBreedFieldResolver
//
//     // IsTypeOf is used to determine if a given value is associated with the Dog type
//     IsTypeOf(interface{}, graphql.IsTypeOfParams) bool
//   }
//
// == Example implementation ...
//
//   // DogResolver implements DogFieldResolvers interface
//   type DogResolver struct {
//     logger logrus.LogEntry
//     store interface{
//       store.BreedStore
//       store.DogStore
//     }
//   }
//
//   // Name implements response to request for name field.
//   func (r *DogResolver) Name(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     return dog.GetName()
//   }
//
//   // Breed implements response to request for breed field.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     breed := r.store.GetBreed(dog.GetBreedName())
//     return breed
//   }
//
//   // IsTypeOf is used to determine if a given value is associated with the Dog type
//   func (r *DogResolver) IsTypeOf(p graphql.IsTypeOfParams) bool {
//     // ... implementation details ...
//     _, ok := p.Value.(DogGetter)
//     return ok
//   }
//
type UntypedMetricFieldResolvers interface {
	UntypedMetricLabelsFieldResolver
	UntypedMetricTimestampFieldResolver
	UntypedMetricValueFieldResolver
}

// UntypedMetricAliases implements all methods on UntypedMetricFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
//
// == Example SDL
//
//    type Dog {
//      name:   String!
//      weight: Float!
//      dob:    DateTime
//      breed:  [Breed]
//    }
//
// == Example generated aliases
//
//   type DogAliases struct {}
//   func (_ DogAliases) Name(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Weight(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Dob(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//
// == Example Implementation
//
//   type DogResolver struct { // Implements DogResolver
//     DogAliases
//     store store.BreedStore
//   }
//
//   // NOTE:
//   // All other fields are satisified by DogAliases but since this one
//   // requires hitting the store we implement it in our resolver.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) interface{} {
//     dog := v.(*Dog)
//     return r.BreedsById(dog.BreedIDs)
//   }
//
type UntypedMetricAliases struct{}

// Labels implements response to request for 'labels' field.
func (_ UntypedMetricAliases) Labels(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	return val, err
}

// Timestamp implements response to request for 'timestamp' field.
func (_ UntypedMetricAliases) Timestamp(p graphql.ResolveParams) (*time.Time, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := val.(*time.Time)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'timestamp'")
	}
	return ret, err
}

// Value implements response to request for 'value' field.
func (_ UntypedMetricAliases) Value(p graphql.ResolveParams) (float64, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Float.ParseValue(val).(float64)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'value'")
	}
	return ret, err
}

// UntypedMetricType self descriptive
var UntypedMetricType = graphql.NewType("UntypedMetric", graphql.ObjectKind)

// RegisterUntypedMetric registers UntypedMetric object type with given service.
func RegisterUntypedMetric(svc *graphql.Service, impl UntypedMetricFieldResolvers) {
	svc.RegisterObject(_ObjectTypeUntypedMetricDesc, impl)
}
func _ObjTypeUntypedMetricLabelsHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(UntypedMetricLabelsFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Labels(frp)
	}
}

func _ObjTypeUntypedMetricTimestampHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(UntypedMetricTimestampFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Timestamp(frp)
	}
}

func _ObjTypeUntypedMetricValueHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(UntypedMetricValueFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Value(frp)
	}
}

func _ObjectTypeUntypedMetricConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{
			"labels": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "labels",
				Type:              graphql1.NewNonNull(graphql1.NewList(graphql1.NewNonNull(graphql.OutputType("KVPairString")))),
			},
			"timestamp": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "timestamp",
				Type:              graphql1.DateTime,
			},
			"value": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "value",
				Type:              graphql1.Float,
			},
		},
		Interfaces: []*graphql1.Interface{
			graphql.Interface("Metric")},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see UntypedMetricFieldResolvers.")
		},
		Name: "UntypedMetric",
	}
}

// describe UntypedMetric's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeUntypedMetricDesc = graphql.ObjectDesc{
	Config: _ObjectTypeUntypedMetricConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{
		"labels":    _ObjTypeUntypedMetricLabelsHandler,
		"timestamp": _ObjTypeUntypedMetricTimestampHandler,
		"value":     _ObjTypeUntypedMetricValueHandler,
	},
}

// HistogramMetricLabelsFieldResolver implement to resolve requests for the HistogramMetric's labels field.
type HistogramMetricLabelsFieldResolver interface {
	// Labels implements response to request for labels field.
	Labels(p graphql.ResolveParams) (interface{}, error)
}

// HistogramMetricTimestampFieldResolver implement to resolve requests for the HistogramMetric's timestamp field.
type HistogramMetricTimestampFieldResolver interface {
	// Timestamp implements response to request for timestamp field.
	Timestamp(p graphql.ResolveParams) (*time.Time, error)
}

// HistogramMetricSampleCountFieldResolver implement to resolve requests for the HistogramMetric's sampleCount field.
type HistogramMetricSampleCountFieldResolver interface {
	// SampleCount implements response to request for sampleCount field.
	SampleCount(p graphql.ResolveParams) (int, error)
}

// HistogramMetricSampleSumFieldResolver implement to resolve requests for the HistogramMetric's sampleSum field.
type HistogramMetricSampleSumFieldResolver interface {
	// SampleSum implements response to request for sampleSum field.
	SampleSum(p graphql.ResolveParams) (float64, error)
}

// HistogramMetricBucketFieldResolver implement to resolve requests for the HistogramMetric's bucket field.
type HistogramMetricBucketFieldResolver interface {
	// Bucket implements response to request for bucket field.
	Bucket(p graphql.ResolveParams) (interface{}, error)
}

//
// HistogramMetricFieldResolvers represents a collection of methods whose products represent the
// response values of the 'HistogramMetric' type.
//
// == Example SDL
//
//   """
//   Dog's are not hooman.
//   """
//   type Dog implements Pet {
//     "name of this fine beast."
//     name:  String!
//
//     "breed of this silly animal; probably shibe."
//     breed: [Breed]
//   }
//
// == Example generated interface
//
//   // DogResolver ...
//   type DogFieldResolvers interface {
//     DogNameFieldResolver
//     DogBreedFieldResolver
//
//     // IsTypeOf is used to determine if a given value is associated with the Dog type
//     IsTypeOf(interface{}, graphql.IsTypeOfParams) bool
//   }
//
// == Example implementation ...
//
//   // DogResolver implements DogFieldResolvers interface
//   type DogResolver struct {
//     logger logrus.LogEntry
//     store interface{
//       store.BreedStore
//       store.DogStore
//     }
//   }
//
//   // Name implements response to request for name field.
//   func (r *DogResolver) Name(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     return dog.GetName()
//   }
//
//   // Breed implements response to request for breed field.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     breed := r.store.GetBreed(dog.GetBreedName())
//     return breed
//   }
//
//   // IsTypeOf is used to determine if a given value is associated with the Dog type
//   func (r *DogResolver) IsTypeOf(p graphql.IsTypeOfParams) bool {
//     // ... implementation details ...
//     _, ok := p.Value.(DogGetter)
//     return ok
//   }
//
type HistogramMetricFieldResolvers interface {
	HistogramMetricLabelsFieldResolver
	HistogramMetricTimestampFieldResolver
	HistogramMetricSampleCountFieldResolver
	HistogramMetricSampleSumFieldResolver
	HistogramMetricBucketFieldResolver
}

// HistogramMetricAliases implements all methods on HistogramMetricFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
//
// == Example SDL
//
//    type Dog {
//      name:   String!
//      weight: Float!
//      dob:    DateTime
//      breed:  [Breed]
//    }
//
// == Example generated aliases
//
//   type DogAliases struct {}
//   func (_ DogAliases) Name(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Weight(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Dob(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//
// == Example Implementation
//
//   type DogResolver struct { // Implements DogResolver
//     DogAliases
//     store store.BreedStore
//   }
//
//   // NOTE:
//   // All other fields are satisified by DogAliases but since this one
//   // requires hitting the store we implement it in our resolver.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) interface{} {
//     dog := v.(*Dog)
//     return r.BreedsById(dog.BreedIDs)
//   }
//
type HistogramMetricAliases struct{}

// Labels implements response to request for 'labels' field.
func (_ HistogramMetricAliases) Labels(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	return val, err
}

// Timestamp implements response to request for 'timestamp' field.
func (_ HistogramMetricAliases) Timestamp(p graphql.ResolveParams) (*time.Time, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := val.(*time.Time)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'timestamp'")
	}
	return ret, err
}

// SampleCount implements response to request for 'sampleCount' field.
func (_ HistogramMetricAliases) SampleCount(p graphql.ResolveParams) (int, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Int.ParseValue(val).(int)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'sampleCount'")
	}
	return ret, err
}

// SampleSum implements response to request for 'sampleSum' field.
func (_ HistogramMetricAliases) SampleSum(p graphql.ResolveParams) (float64, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Float.ParseValue(val).(float64)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'sampleSum'")
	}
	return ret, err
}

// Bucket implements response to request for 'bucket' field.
func (_ HistogramMetricAliases) Bucket(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	return val, err
}

// HistogramMetricType self descriptive
var HistogramMetricType = graphql.NewType("HistogramMetric", graphql.ObjectKind)

// RegisterHistogramMetric registers HistogramMetric object type with given service.
func RegisterHistogramMetric(svc *graphql.Service, impl HistogramMetricFieldResolvers) {
	svc.RegisterObject(_ObjectTypeHistogramMetricDesc, impl)
}
func _ObjTypeHistogramMetricLabelsHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(HistogramMetricLabelsFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Labels(frp)
	}
}

func _ObjTypeHistogramMetricTimestampHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(HistogramMetricTimestampFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Timestamp(frp)
	}
}

func _ObjTypeHistogramMetricSampleCountHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(HistogramMetricSampleCountFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.SampleCount(frp)
	}
}

func _ObjTypeHistogramMetricSampleSumHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(HistogramMetricSampleSumFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.SampleSum(frp)
	}
}

func _ObjTypeHistogramMetricBucketHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(HistogramMetricBucketFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Bucket(frp)
	}
}

func _ObjectTypeHistogramMetricConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{
			"bucket": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "bucket",
				Type:              graphql1.NewNonNull(graphql1.NewList(graphql.OutputType("BucketMetric"))),
			},
			"labels": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "labels",
				Type:              graphql1.NewNonNull(graphql1.NewList(graphql1.NewNonNull(graphql.OutputType("KVPairString")))),
			},
			"sampleCount": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "sampleCount",
				Type:              graphql1.Int,
			},
			"sampleSum": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "sampleSum",
				Type:              graphql1.Float,
			},
			"timestamp": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "timestamp",
				Type:              graphql1.DateTime,
			},
		},
		Interfaces: []*graphql1.Interface{
			graphql.Interface("Metric")},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see HistogramMetricFieldResolvers.")
		},
		Name: "HistogramMetric",
	}
}

// describe HistogramMetric's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeHistogramMetricDesc = graphql.ObjectDesc{
	Config: _ObjectTypeHistogramMetricConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{
		"bucket":      _ObjTypeHistogramMetricBucketHandler,
		"labels":      _ObjTypeHistogramMetricLabelsHandler,
		"sampleCount": _ObjTypeHistogramMetricSampleCountHandler,
		"sampleSum":   _ObjTypeHistogramMetricSampleSumHandler,
		"timestamp":   _ObjTypeHistogramMetricTimestampHandler,
	},
}

// MetricFamilyNameFieldResolver implement to resolve requests for the MetricFamily's name field.
type MetricFamilyNameFieldResolver interface {
	// Name implements response to request for name field.
	Name(p graphql.ResolveParams) (string, error)
}

// MetricFamilyHelpFieldResolver implement to resolve requests for the MetricFamily's help field.
type MetricFamilyHelpFieldResolver interface {
	// Help implements response to request for help field.
	Help(p graphql.ResolveParams) (string, error)
}

// MetricFamilyTypeFieldResolver implement to resolve requests for the MetricFamily's type field.
type MetricFamilyTypeFieldResolver interface {
	// Type implements response to request for type field.
	Type(p graphql.ResolveParams) (MetricKind, error)
}

// MetricFamilyMetricFieldResolver implement to resolve requests for the MetricFamily's metric field.
type MetricFamilyMetricFieldResolver interface {
	// Metric implements response to request for metric field.
	Metric(p graphql.ResolveParams) (interface{}, error)
}

//
// MetricFamilyFieldResolvers represents a collection of methods whose products represent the
// response values of the 'MetricFamily' type.
//
// == Example SDL
//
//   """
//   Dog's are not hooman.
//   """
//   type Dog implements Pet {
//     "name of this fine beast."
//     name:  String!
//
//     "breed of this silly animal; probably shibe."
//     breed: [Breed]
//   }
//
// == Example generated interface
//
//   // DogResolver ...
//   type DogFieldResolvers interface {
//     DogNameFieldResolver
//     DogBreedFieldResolver
//
//     // IsTypeOf is used to determine if a given value is associated with the Dog type
//     IsTypeOf(interface{}, graphql.IsTypeOfParams) bool
//   }
//
// == Example implementation ...
//
//   // DogResolver implements DogFieldResolvers interface
//   type DogResolver struct {
//     logger logrus.LogEntry
//     store interface{
//       store.BreedStore
//       store.DogStore
//     }
//   }
//
//   // Name implements response to request for name field.
//   func (r *DogResolver) Name(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     return dog.GetName()
//   }
//
//   // Breed implements response to request for breed field.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     breed := r.store.GetBreed(dog.GetBreedName())
//     return breed
//   }
//
//   // IsTypeOf is used to determine if a given value is associated with the Dog type
//   func (r *DogResolver) IsTypeOf(p graphql.IsTypeOfParams) bool {
//     // ... implementation details ...
//     _, ok := p.Value.(DogGetter)
//     return ok
//   }
//
type MetricFamilyFieldResolvers interface {
	MetricFamilyNameFieldResolver
	MetricFamilyHelpFieldResolver
	MetricFamilyTypeFieldResolver
	MetricFamilyMetricFieldResolver
}

// MetricFamilyAliases implements all methods on MetricFamilyFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
//
// == Example SDL
//
//    type Dog {
//      name:   String!
//      weight: Float!
//      dob:    DateTime
//      breed:  [Breed]
//    }
//
// == Example generated aliases
//
//   type DogAliases struct {}
//   func (_ DogAliases) Name(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Weight(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Dob(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//
// == Example Implementation
//
//   type DogResolver struct { // Implements DogResolver
//     DogAliases
//     store store.BreedStore
//   }
//
//   // NOTE:
//   // All other fields are satisified by DogAliases but since this one
//   // requires hitting the store we implement it in our resolver.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) interface{} {
//     dog := v.(*Dog)
//     return r.BreedsById(dog.BreedIDs)
//   }
//
type MetricFamilyAliases struct{}

// Name implements response to request for 'name' field.
func (_ MetricFamilyAliases) Name(p graphql.ResolveParams) (string, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := val.(string)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'name'")
	}
	return ret, err
}

// Help implements response to request for 'help' field.
func (_ MetricFamilyAliases) Help(p graphql.ResolveParams) (string, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := val.(string)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'help'")
	}
	return ret, err
}

// Type implements response to request for 'type' field.
func (_ MetricFamilyAliases) Type(p graphql.ResolveParams) (MetricKind, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := MetricKind(val.(string)), true
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'type'")
	}
	return ret, err
}

// Metric implements response to request for 'metric' field.
func (_ MetricFamilyAliases) Metric(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	return val, err
}

// MetricFamilyType self descriptive
var MetricFamilyType = graphql.NewType("MetricFamily", graphql.ObjectKind)

// RegisterMetricFamily registers MetricFamily object type with given service.
func RegisterMetricFamily(svc *graphql.Service, impl MetricFamilyFieldResolvers) {
	svc.RegisterObject(_ObjectTypeMetricFamilyDesc, impl)
}
func _ObjTypeMetricFamilyNameHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(MetricFamilyNameFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Name(frp)
	}
}

func _ObjTypeMetricFamilyHelpHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(MetricFamilyHelpFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Help(frp)
	}
}

func _ObjTypeMetricFamilyTypeHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(MetricFamilyTypeFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {

		val, err := resolver.Type(frp)
		return string(val), err
	}
}

func _ObjTypeMetricFamilyMetricHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(MetricFamilyMetricFieldResolver)
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Metric(frp)
	}
}

func _ObjectTypeMetricFamilyConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{
			"help": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "help",
				Type:              graphql1.String,
			},
			"metric": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "metric",
				Type:              graphql1.NewNonNull(graphql1.NewList(graphql.OutputType("Metric"))),
			},
			"name": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "name",
				Type:              graphql1.String,
			},
			"type": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "type",
				Type:              graphql1.NewNonNull(graphql.OutputType("MetricKind")),
			},
		},
		Interfaces: []*graphql1.Interface{},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see MetricFamilyFieldResolvers.")
		},
		Name: "MetricFamily",
	}
}

// describe MetricFamily's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeMetricFamilyDesc = graphql.ObjectDesc{
	Config: _ObjectTypeMetricFamilyConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{
		"help":   _ObjTypeMetricFamilyHelpHandler,
		"metric": _ObjTypeMetricFamilyMetricHandler,
		"name":   _ObjTypeMetricFamilyNameHandler,
		"type":   _ObjTypeMetricFamilyTypeHandler,
	},
}
