// Code generated by scripts/gengraphql.go. DO NOT EDIT.

package schema

import (
	errors "errors"
	graphql1 "github.com/graphql-go/graphql"
	graphql "github.com/sensu/sensu-go/graphql"
	time "time"
)

// MetricType self descriptive
var MetricType = graphql.NewType("Metric", graphql.InterfaceKind)

// RegisterMetric registers Metric object type with given service.
func RegisterMetric(svc *graphql.Service, impl graphql.InterfaceTypeResolver) {
	svc.RegisterInterface(_InterfaceTypeMetricDesc, impl)
}
func _InterfaceTypeMetricConfigFn() graphql1.InterfaceConfig {
	return graphql1.InterfaceConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{
			"labels": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "labels",
				Type:              graphql1.NewNonNull(graphql1.NewList(graphql1.NewNonNull(graphql.OutputType("KVPairString")))),
			},
			"timestamp": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "timestamp",
				Type:              graphql1.DateTime,
			},
		},
		Name: "Metric",
		ResolveType: func(_ graphql1.ResolveTypeParams) *graphql1.Object {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see InterfaceTypeResolver.")
		},
	}
}

// describe Metric's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _InterfaceTypeMetricDesc = graphql.InterfaceDesc{Config: _InterfaceTypeMetricConfigFn}

// MetricKind self descriptive
type MetricKind string

// MetricKinds holds enum values
var MetricKinds = _EnumTypeMetricKindValues{
	COUNTER:   "COUNTER",
	GAUGE:     "GAUGE",
	HISTOGRAM: "HISTOGRAM",
	SUMMARY:   "SUMMARY",
	UNTYPED:   "UNTYPED",
}

// MetricKindType self descriptive
var MetricKindType = graphql.NewType("MetricKind", graphql.EnumKind)

// RegisterMetricKind registers MetricKind object type with given service.
func RegisterMetricKind(svc *graphql.Service) {
	svc.RegisterEnum(_EnumTypeMetricKindDesc)
}
func _EnumTypeMetricKindConfigFn() graphql1.EnumConfig {
	return graphql1.EnumConfig{
		Description: "self descriptive",
		Name:        "MetricKind",
		Values: graphql1.EnumValueConfigMap{
			"COUNTER": &graphql1.EnumValueConfig{
				DeprecationReason: "",
				Description:       "self descriptive",
				Value:             "COUNTER",
			},
			"GAUGE": &graphql1.EnumValueConfig{
				DeprecationReason: "",
				Description:       "self descriptive",
				Value:             "GAUGE",
			},
			"HISTOGRAM": &graphql1.EnumValueConfig{
				DeprecationReason: "",
				Description:       "self descriptive",
				Value:             "HISTOGRAM",
			},
			"SUMMARY": &graphql1.EnumValueConfig{
				DeprecationReason: "",
				Description:       "self descriptive",
				Value:             "SUMMARY",
			},
			"UNTYPED": &graphql1.EnumValueConfig{
				DeprecationReason: "",
				Description:       "self descriptive",
				Value:             "UNTYPED",
			},
		},
	}
}

// describe MetricKind's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _EnumTypeMetricKindDesc = graphql.EnumDesc{Config: _EnumTypeMetricKindConfigFn}

type _EnumTypeMetricKindValues struct {
	// COUNTER - self descriptive
	COUNTER MetricKind
	// GAUGE - self descriptive
	GAUGE MetricKind
	// SUMMARY - self descriptive
	SUMMARY MetricKind
	// UNTYPED - self descriptive
	UNTYPED MetricKind
	// HISTOGRAM - self descriptive
	HISTOGRAM MetricKind
}

// QuantileMetricFieldResolvers represents a collection of methods whose products represent the
// response values of the 'QuantileMetric' type.
type QuantileMetricFieldResolvers interface {
	// Quantile implements response to request for 'quantile' field.
	Quantile(p graphql.ResolveParams) (float64, error)

	// Value implements response to request for 'value' field.
	Value(p graphql.ResolveParams) (float64, error)
}

// QuantileMetricAliases implements all methods on QuantileMetricFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
type QuantileMetricAliases struct{}

// Quantile implements response to request for 'quantile' field.
func (_ QuantileMetricAliases) Quantile(p graphql.ResolveParams) (float64, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Float.ParseValue(val).(float64)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'quantile'")
	}
	return ret, err
}

// Value implements response to request for 'value' field.
func (_ QuantileMetricAliases) Value(p graphql.ResolveParams) (float64, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Float.ParseValue(val).(float64)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'value'")
	}
	return ret, err
}

// QuantileMetricType self descriptive
var QuantileMetricType = graphql.NewType("QuantileMetric", graphql.ObjectKind)

// RegisterQuantileMetric registers QuantileMetric object type with given service.
func RegisterQuantileMetric(svc *graphql.Service, impl QuantileMetricFieldResolvers) {
	svc.RegisterObject(_ObjectTypeQuantileMetricDesc, impl)
}
func _ObjTypeQuantileMetricQuantileHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Quantile(p graphql.ResolveParams) (float64, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Quantile(frp)
	}
}

func _ObjTypeQuantileMetricValueHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Value(p graphql.ResolveParams) (float64, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Value(frp)
	}
}

func _ObjectTypeQuantileMetricConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{
			"quantile": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "quantile",
				Type:              graphql1.Float,
			},
			"value": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "value",
				Type:              graphql1.Float,
			},
		},
		Interfaces: []*graphql1.Interface{},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see QuantileMetricFieldResolvers.")
		},
		Name: "QuantileMetric",
	}
}

// describe QuantileMetric's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeQuantileMetricDesc = graphql.ObjectDesc{
	Config: _ObjectTypeQuantileMetricConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{
		"quantile": _ObjTypeQuantileMetricQuantileHandler,
		"value":    _ObjTypeQuantileMetricValueHandler,
	},
}

// BucketMetricFieldResolvers represents a collection of methods whose products represent the
// response values of the 'BucketMetric' type.
type BucketMetricFieldResolvers interface {
	// CumulativeCount implements response to request for 'cumulativeCount' field.
	CumulativeCount(p graphql.ResolveParams) (int, error)

	// UpperBound implements response to request for 'upperBound' field.
	UpperBound(p graphql.ResolveParams) (float64, error)
}

// BucketMetricAliases implements all methods on BucketMetricFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
type BucketMetricAliases struct{}

// CumulativeCount implements response to request for 'cumulativeCount' field.
func (_ BucketMetricAliases) CumulativeCount(p graphql.ResolveParams) (int, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Int.ParseValue(val).(int)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'cumulativeCount'")
	}
	return ret, err
}

// UpperBound implements response to request for 'upperBound' field.
func (_ BucketMetricAliases) UpperBound(p graphql.ResolveParams) (float64, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Float.ParseValue(val).(float64)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'upperBound'")
	}
	return ret, err
}

// BucketMetricType self descriptive
var BucketMetricType = graphql.NewType("BucketMetric", graphql.ObjectKind)

// RegisterBucketMetric registers BucketMetric object type with given service.
func RegisterBucketMetric(svc *graphql.Service, impl BucketMetricFieldResolvers) {
	svc.RegisterObject(_ObjectTypeBucketMetricDesc, impl)
}
func _ObjTypeBucketMetricCumulativeCountHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		CumulativeCount(p graphql.ResolveParams) (int, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.CumulativeCount(frp)
	}
}

func _ObjTypeBucketMetricUpperBoundHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		UpperBound(p graphql.ResolveParams) (float64, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.UpperBound(frp)
	}
}

func _ObjectTypeBucketMetricConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{
			"cumulativeCount": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "cumulativeCount",
				Type:              graphql1.Int,
			},
			"upperBound": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "upperBound",
				Type:              graphql1.Float,
			},
		},
		Interfaces: []*graphql1.Interface{},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see BucketMetricFieldResolvers.")
		},
		Name: "BucketMetric",
	}
}

// describe BucketMetric's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeBucketMetricDesc = graphql.ObjectDesc{
	Config: _ObjectTypeBucketMetricConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{
		"cumulativeCount": _ObjTypeBucketMetricCumulativeCountHandler,
		"upperBound":      _ObjTypeBucketMetricUpperBoundHandler,
	},
}

// CounterMetricFieldResolvers represents a collection of methods whose products represent the
// response values of the 'CounterMetric' type.
type CounterMetricFieldResolvers interface {
	// Labels implements response to request for 'labels' field.
	Labels(p graphql.ResolveParams) (interface{}, error)

	// Timestamp implements response to request for 'timestamp' field.
	Timestamp(p graphql.ResolveParams) (*time.Time, error)

	// Value implements response to request for 'value' field.
	Value(p graphql.ResolveParams) (float64, error)
}

// CounterMetricAliases implements all methods on CounterMetricFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
type CounterMetricAliases struct{}

// Labels implements response to request for 'labels' field.
func (_ CounterMetricAliases) Labels(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	return val, err
}

// Timestamp implements response to request for 'timestamp' field.
func (_ CounterMetricAliases) Timestamp(p graphql.ResolveParams) (*time.Time, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := val.(*time.Time)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'timestamp'")
	}
	return ret, err
}

// Value implements response to request for 'value' field.
func (_ CounterMetricAliases) Value(p graphql.ResolveParams) (float64, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Float.ParseValue(val).(float64)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'value'")
	}
	return ret, err
}

// CounterMetricType self descriptive
var CounterMetricType = graphql.NewType("CounterMetric", graphql.ObjectKind)

// RegisterCounterMetric registers CounterMetric object type with given service.
func RegisterCounterMetric(svc *graphql.Service, impl CounterMetricFieldResolvers) {
	svc.RegisterObject(_ObjectTypeCounterMetricDesc, impl)
}
func _ObjTypeCounterMetricLabelsHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Labels(p graphql.ResolveParams) (interface{}, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Labels(frp)
	}
}

func _ObjTypeCounterMetricTimestampHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Timestamp(p graphql.ResolveParams) (*time.Time, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Timestamp(frp)
	}
}

func _ObjTypeCounterMetricValueHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Value(p graphql.ResolveParams) (float64, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Value(frp)
	}
}

func _ObjectTypeCounterMetricConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{
			"labels": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "labels",
				Type:              graphql1.NewNonNull(graphql1.NewList(graphql1.NewNonNull(graphql.OutputType("KVPairString")))),
			},
			"timestamp": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "timestamp",
				Type:              graphql1.DateTime,
			},
			"value": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "value",
				Type:              graphql1.Float,
			},
		},
		Interfaces: []*graphql1.Interface{
			graphql.Interface("Metric")},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see CounterMetricFieldResolvers.")
		},
		Name: "CounterMetric",
	}
}

// describe CounterMetric's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeCounterMetricDesc = graphql.ObjectDesc{
	Config: _ObjectTypeCounterMetricConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{
		"labels":    _ObjTypeCounterMetricLabelsHandler,
		"timestamp": _ObjTypeCounterMetricTimestampHandler,
		"value":     _ObjTypeCounterMetricValueHandler,
	},
}

// GaugeMetricFieldResolvers represents a collection of methods whose products represent the
// response values of the 'GaugeMetric' type.
type GaugeMetricFieldResolvers interface {
	// Labels implements response to request for 'labels' field.
	Labels(p graphql.ResolveParams) (interface{}, error)

	// Timestamp implements response to request for 'timestamp' field.
	Timestamp(p graphql.ResolveParams) (*time.Time, error)

	// Value implements response to request for 'value' field.
	Value(p graphql.ResolveParams) (float64, error)
}

// GaugeMetricAliases implements all methods on GaugeMetricFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
type GaugeMetricAliases struct{}

// Labels implements response to request for 'labels' field.
func (_ GaugeMetricAliases) Labels(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	return val, err
}

// Timestamp implements response to request for 'timestamp' field.
func (_ GaugeMetricAliases) Timestamp(p graphql.ResolveParams) (*time.Time, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := val.(*time.Time)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'timestamp'")
	}
	return ret, err
}

// Value implements response to request for 'value' field.
func (_ GaugeMetricAliases) Value(p graphql.ResolveParams) (float64, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Float.ParseValue(val).(float64)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'value'")
	}
	return ret, err
}

// GaugeMetricType self descriptive
var GaugeMetricType = graphql.NewType("GaugeMetric", graphql.ObjectKind)

// RegisterGaugeMetric registers GaugeMetric object type with given service.
func RegisterGaugeMetric(svc *graphql.Service, impl GaugeMetricFieldResolvers) {
	svc.RegisterObject(_ObjectTypeGaugeMetricDesc, impl)
}
func _ObjTypeGaugeMetricLabelsHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Labels(p graphql.ResolveParams) (interface{}, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Labels(frp)
	}
}

func _ObjTypeGaugeMetricTimestampHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Timestamp(p graphql.ResolveParams) (*time.Time, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Timestamp(frp)
	}
}

func _ObjTypeGaugeMetricValueHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Value(p graphql.ResolveParams) (float64, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Value(frp)
	}
}

func _ObjectTypeGaugeMetricConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{
			"labels": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "labels",
				Type:              graphql1.NewNonNull(graphql1.NewList(graphql1.NewNonNull(graphql.OutputType("KVPairString")))),
			},
			"timestamp": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "timestamp",
				Type:              graphql1.DateTime,
			},
			"value": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "value",
				Type:              graphql1.Float,
			},
		},
		Interfaces: []*graphql1.Interface{
			graphql.Interface("Metric")},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see GaugeMetricFieldResolvers.")
		},
		Name: "GaugeMetric",
	}
}

// describe GaugeMetric's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeGaugeMetricDesc = graphql.ObjectDesc{
	Config: _ObjectTypeGaugeMetricConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{
		"labels":    _ObjTypeGaugeMetricLabelsHandler,
		"timestamp": _ObjTypeGaugeMetricTimestampHandler,
		"value":     _ObjTypeGaugeMetricValueHandler,
	},
}

// SummaryMetricFieldResolvers represents a collection of methods whose products represent the
// response values of the 'SummaryMetric' type.
type SummaryMetricFieldResolvers interface {
	// Labels implements response to request for 'labels' field.
	Labels(p graphql.ResolveParams) (interface{}, error)

	// Timestamp implements response to request for 'timestamp' field.
	Timestamp(p graphql.ResolveParams) (*time.Time, error)

	// SampleCount implements response to request for 'sampleCount' field.
	SampleCount(p graphql.ResolveParams) (int, error)

	// SampleSum implements response to request for 'sampleSum' field.
	SampleSum(p graphql.ResolveParams) (float64, error)

	// Quantile implements response to request for 'quantile' field.
	Quantile(p graphql.ResolveParams) (interface{}, error)
}

// SummaryMetricAliases implements all methods on SummaryMetricFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
type SummaryMetricAliases struct{}

// Labels implements response to request for 'labels' field.
func (_ SummaryMetricAliases) Labels(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	return val, err
}

// Timestamp implements response to request for 'timestamp' field.
func (_ SummaryMetricAliases) Timestamp(p graphql.ResolveParams) (*time.Time, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := val.(*time.Time)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'timestamp'")
	}
	return ret, err
}

// SampleCount implements response to request for 'sampleCount' field.
func (_ SummaryMetricAliases) SampleCount(p graphql.ResolveParams) (int, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Int.ParseValue(val).(int)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'sampleCount'")
	}
	return ret, err
}

// SampleSum implements response to request for 'sampleSum' field.
func (_ SummaryMetricAliases) SampleSum(p graphql.ResolveParams) (float64, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Float.ParseValue(val).(float64)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'sampleSum'")
	}
	return ret, err
}

// Quantile implements response to request for 'quantile' field.
func (_ SummaryMetricAliases) Quantile(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	return val, err
}

// SummaryMetricType self descriptive
var SummaryMetricType = graphql.NewType("SummaryMetric", graphql.ObjectKind)

// RegisterSummaryMetric registers SummaryMetric object type with given service.
func RegisterSummaryMetric(svc *graphql.Service, impl SummaryMetricFieldResolvers) {
	svc.RegisterObject(_ObjectTypeSummaryMetricDesc, impl)
}
func _ObjTypeSummaryMetricLabelsHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Labels(p graphql.ResolveParams) (interface{}, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Labels(frp)
	}
}

func _ObjTypeSummaryMetricTimestampHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Timestamp(p graphql.ResolveParams) (*time.Time, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Timestamp(frp)
	}
}

func _ObjTypeSummaryMetricSampleCountHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		SampleCount(p graphql.ResolveParams) (int, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.SampleCount(frp)
	}
}

func _ObjTypeSummaryMetricSampleSumHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		SampleSum(p graphql.ResolveParams) (float64, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.SampleSum(frp)
	}
}

func _ObjTypeSummaryMetricQuantileHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Quantile(p graphql.ResolveParams) (interface{}, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Quantile(frp)
	}
}

func _ObjectTypeSummaryMetricConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{
			"labels": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "labels",
				Type:              graphql1.NewNonNull(graphql1.NewList(graphql1.NewNonNull(graphql.OutputType("KVPairString")))),
			},
			"quantile": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "quantile",
				Type:              graphql1.NewNonNull(graphql1.NewList(graphql.OutputType("QuantileMetric"))),
			},
			"sampleCount": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "sampleCount",
				Type:              graphql1.Int,
			},
			"sampleSum": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "sampleSum",
				Type:              graphql1.Float,
			},
			"timestamp": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "timestamp",
				Type:              graphql1.DateTime,
			},
		},
		Interfaces: []*graphql1.Interface{
			graphql.Interface("Metric")},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see SummaryMetricFieldResolvers.")
		},
		Name: "SummaryMetric",
	}
}

// describe SummaryMetric's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeSummaryMetricDesc = graphql.ObjectDesc{
	Config: _ObjectTypeSummaryMetricConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{
		"labels":      _ObjTypeSummaryMetricLabelsHandler,
		"quantile":    _ObjTypeSummaryMetricQuantileHandler,
		"sampleCount": _ObjTypeSummaryMetricSampleCountHandler,
		"sampleSum":   _ObjTypeSummaryMetricSampleSumHandler,
		"timestamp":   _ObjTypeSummaryMetricTimestampHandler,
	},
}

// UntypedMetricFieldResolvers represents a collection of methods whose products represent the
// response values of the 'UntypedMetric' type.
type UntypedMetricFieldResolvers interface {
	// Labels implements response to request for 'labels' field.
	Labels(p graphql.ResolveParams) (interface{}, error)

	// Timestamp implements response to request for 'timestamp' field.
	Timestamp(p graphql.ResolveParams) (*time.Time, error)

	// Value implements response to request for 'value' field.
	Value(p graphql.ResolveParams) (float64, error)
}

// UntypedMetricAliases implements all methods on UntypedMetricFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
type UntypedMetricAliases struct{}

// Labels implements response to request for 'labels' field.
func (_ UntypedMetricAliases) Labels(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	return val, err
}

// Timestamp implements response to request for 'timestamp' field.
func (_ UntypedMetricAliases) Timestamp(p graphql.ResolveParams) (*time.Time, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := val.(*time.Time)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'timestamp'")
	}
	return ret, err
}

// Value implements response to request for 'value' field.
func (_ UntypedMetricAliases) Value(p graphql.ResolveParams) (float64, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Float.ParseValue(val).(float64)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'value'")
	}
	return ret, err
}

// UntypedMetricType self descriptive
var UntypedMetricType = graphql.NewType("UntypedMetric", graphql.ObjectKind)

// RegisterUntypedMetric registers UntypedMetric object type with given service.
func RegisterUntypedMetric(svc *graphql.Service, impl UntypedMetricFieldResolvers) {
	svc.RegisterObject(_ObjectTypeUntypedMetricDesc, impl)
}
func _ObjTypeUntypedMetricLabelsHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Labels(p graphql.ResolveParams) (interface{}, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Labels(frp)
	}
}

func _ObjTypeUntypedMetricTimestampHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Timestamp(p graphql.ResolveParams) (*time.Time, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Timestamp(frp)
	}
}

func _ObjTypeUntypedMetricValueHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Value(p graphql.ResolveParams) (float64, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Value(frp)
	}
}

func _ObjectTypeUntypedMetricConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{
			"labels": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "labels",
				Type:              graphql1.NewNonNull(graphql1.NewList(graphql1.NewNonNull(graphql.OutputType("KVPairString")))),
			},
			"timestamp": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "timestamp",
				Type:              graphql1.DateTime,
			},
			"value": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "value",
				Type:              graphql1.Float,
			},
		},
		Interfaces: []*graphql1.Interface{
			graphql.Interface("Metric")},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see UntypedMetricFieldResolvers.")
		},
		Name: "UntypedMetric",
	}
}

// describe UntypedMetric's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeUntypedMetricDesc = graphql.ObjectDesc{
	Config: _ObjectTypeUntypedMetricConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{
		"labels":    _ObjTypeUntypedMetricLabelsHandler,
		"timestamp": _ObjTypeUntypedMetricTimestampHandler,
		"value":     _ObjTypeUntypedMetricValueHandler,
	},
}

// HistogramMetricFieldResolvers represents a collection of methods whose products represent the
// response values of the 'HistogramMetric' type.
type HistogramMetricFieldResolvers interface {
	// Labels implements response to request for 'labels' field.
	Labels(p graphql.ResolveParams) (interface{}, error)

	// Timestamp implements response to request for 'timestamp' field.
	Timestamp(p graphql.ResolveParams) (*time.Time, error)

	// SampleCount implements response to request for 'sampleCount' field.
	SampleCount(p graphql.ResolveParams) (int, error)

	// SampleSum implements response to request for 'sampleSum' field.
	SampleSum(p graphql.ResolveParams) (float64, error)

	// Bucket implements response to request for 'bucket' field.
	Bucket(p graphql.ResolveParams) (interface{}, error)
}

// HistogramMetricAliases implements all methods on HistogramMetricFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
type HistogramMetricAliases struct{}

// Labels implements response to request for 'labels' field.
func (_ HistogramMetricAliases) Labels(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	return val, err
}

// Timestamp implements response to request for 'timestamp' field.
func (_ HistogramMetricAliases) Timestamp(p graphql.ResolveParams) (*time.Time, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := val.(*time.Time)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'timestamp'")
	}
	return ret, err
}

// SampleCount implements response to request for 'sampleCount' field.
func (_ HistogramMetricAliases) SampleCount(p graphql.ResolveParams) (int, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Int.ParseValue(val).(int)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'sampleCount'")
	}
	return ret, err
}

// SampleSum implements response to request for 'sampleSum' field.
func (_ HistogramMetricAliases) SampleSum(p graphql.ResolveParams) (float64, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := graphql1.Float.ParseValue(val).(float64)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'sampleSum'")
	}
	return ret, err
}

// Bucket implements response to request for 'bucket' field.
func (_ HistogramMetricAliases) Bucket(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	return val, err
}

// HistogramMetricType self descriptive
var HistogramMetricType = graphql.NewType("HistogramMetric", graphql.ObjectKind)

// RegisterHistogramMetric registers HistogramMetric object type with given service.
func RegisterHistogramMetric(svc *graphql.Service, impl HistogramMetricFieldResolvers) {
	svc.RegisterObject(_ObjectTypeHistogramMetricDesc, impl)
}
func _ObjTypeHistogramMetricLabelsHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Labels(p graphql.ResolveParams) (interface{}, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Labels(frp)
	}
}

func _ObjTypeHistogramMetricTimestampHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Timestamp(p graphql.ResolveParams) (*time.Time, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Timestamp(frp)
	}
}

func _ObjTypeHistogramMetricSampleCountHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		SampleCount(p graphql.ResolveParams) (int, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.SampleCount(frp)
	}
}

func _ObjTypeHistogramMetricSampleSumHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		SampleSum(p graphql.ResolveParams) (float64, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.SampleSum(frp)
	}
}

func _ObjTypeHistogramMetricBucketHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Bucket(p graphql.ResolveParams) (interface{}, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Bucket(frp)
	}
}

func _ObjectTypeHistogramMetricConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{
			"bucket": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "bucket",
				Type:              graphql1.NewNonNull(graphql1.NewList(graphql.OutputType("BucketMetric"))),
			},
			"labels": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "labels",
				Type:              graphql1.NewNonNull(graphql1.NewList(graphql1.NewNonNull(graphql.OutputType("KVPairString")))),
			},
			"sampleCount": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "sampleCount",
				Type:              graphql1.Int,
			},
			"sampleSum": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "sampleSum",
				Type:              graphql1.Float,
			},
			"timestamp": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "timestamp",
				Type:              graphql1.DateTime,
			},
		},
		Interfaces: []*graphql1.Interface{
			graphql.Interface("Metric")},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see HistogramMetricFieldResolvers.")
		},
		Name: "HistogramMetric",
	}
}

// describe HistogramMetric's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeHistogramMetricDesc = graphql.ObjectDesc{
	Config: _ObjectTypeHistogramMetricConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{
		"bucket":      _ObjTypeHistogramMetricBucketHandler,
		"labels":      _ObjTypeHistogramMetricLabelsHandler,
		"sampleCount": _ObjTypeHistogramMetricSampleCountHandler,
		"sampleSum":   _ObjTypeHistogramMetricSampleSumHandler,
		"timestamp":   _ObjTypeHistogramMetricTimestampHandler,
	},
}

// MetricFamilyFieldResolvers represents a collection of methods whose products represent the
// response values of the 'MetricFamily' type.
type MetricFamilyFieldResolvers interface {
	// Name implements response to request for 'name' field.
	Name(p graphql.ResolveParams) (string, error)

	// Help implements response to request for 'help' field.
	Help(p graphql.ResolveParams) (string, error)

	// Type implements response to request for 'type' field.
	Type(p graphql.ResolveParams) (MetricKind, error)

	// Metric implements response to request for 'metric' field.
	Metric(p graphql.ResolveParams) (interface{}, error)
}

// MetricFamilyAliases implements all methods on MetricFamilyFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
type MetricFamilyAliases struct{}

// Name implements response to request for 'name' field.
func (_ MetricFamilyAliases) Name(p graphql.ResolveParams) (string, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := val.(string)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'name'")
	}
	return ret, err
}

// Help implements response to request for 'help' field.
func (_ MetricFamilyAliases) Help(p graphql.ResolveParams) (string, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := val.(string)
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'help'")
	}
	return ret, err
}

// Type implements response to request for 'type' field.
func (_ MetricFamilyAliases) Type(p graphql.ResolveParams) (MetricKind, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret, ok := MetricKind(val.(string)), true
	if err != nil {
		return ret, err
	}
	if !ok {
		return ret, errors.New("unable to coerce value for field 'type'")
	}
	return ret, err
}

// Metric implements response to request for 'metric' field.
func (_ MetricFamilyAliases) Metric(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	return val, err
}

// MetricFamilyType self descriptive
var MetricFamilyType = graphql.NewType("MetricFamily", graphql.ObjectKind)

// RegisterMetricFamily registers MetricFamily object type with given service.
func RegisterMetricFamily(svc *graphql.Service, impl MetricFamilyFieldResolvers) {
	svc.RegisterObject(_ObjectTypeMetricFamilyDesc, impl)
}
func _ObjTypeMetricFamilyNameHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Name(p graphql.ResolveParams) (string, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Name(frp)
	}
}

func _ObjTypeMetricFamilyHelpHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Help(p graphql.ResolveParams) (string, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Help(frp)
	}
}

func _ObjTypeMetricFamilyTypeHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Type(p graphql.ResolveParams) (MetricKind, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {

		val, err := resolver.Type(frp)
		return string(val), err
	}
}

func _ObjTypeMetricFamilyMetricHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(interface {
		Metric(p graphql.ResolveParams) (interface{}, error)
	})
	return func(frp graphql1.ResolveParams) (interface{}, error) {
		return resolver.Metric(frp)
	}
}

func _ObjectTypeMetricFamilyConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{
			"help": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "help",
				Type:              graphql1.String,
			},
			"metric": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "metric",
				Type:              graphql1.NewNonNull(graphql1.NewList(graphql.OutputType("Metric"))),
			},
			"name": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "name",
				Type:              graphql1.String,
			},
			"type": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "type",
				Type:              graphql1.NewNonNull(graphql.OutputType("MetricKind")),
			},
		},
		Interfaces: []*graphql1.Interface{},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see MetricFamilyFieldResolvers.")
		},
		Name: "MetricFamily",
	}
}

// describe MetricFamily's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeMetricFamilyDesc = graphql.ObjectDesc{
	Config: _ObjectTypeMetricFamilyConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{
		"help":   _ObjTypeMetricFamilyHelpHandler,
		"metric": _ObjTypeMetricFamilyMetricHandler,
		"name":   _ObjTypeMetricFamilyNameHandler,
		"type":   _ObjTypeMetricFamilyTypeHandler,
	},
}
