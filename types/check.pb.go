// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: check.proto

package types

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import bytes "bytes"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// A CheckRequest represents a request to execute a check
type CheckRequest struct {
	// Config is the specification of a check.
	Config *CheckConfig `protobuf:"bytes,1,opt,name=config" json:"config,omitempty"`
	// Assets are a list of assets required to execute check.
	Assets []Asset `protobuf:"bytes,2,rep,name=assets" json:"assets"`
	// Hooks are a list of hooks to be executed after a check.
	Hooks []HookConfig `protobuf:"bytes,3,rep,name=hooks" json:"hooks"`
	// Issued describes the time in which the check request was issued
	Issued int64 `protobuf:"varint,4,opt,name=Issued,proto3" json:"issued"`
}

func (m *CheckRequest) Reset()                    { *m = CheckRequest{} }
func (m *CheckRequest) String() string            { return proto.CompactTextString(m) }
func (*CheckRequest) ProtoMessage()               {}
func (*CheckRequest) Descriptor() ([]byte, []int) { return fileDescriptorCheck, []int{0} }

func (m *CheckRequest) GetConfig() *CheckConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *CheckRequest) GetAssets() []Asset {
	if m != nil {
		return m.Assets
	}
	return nil
}

func (m *CheckRequest) GetHooks() []HookConfig {
	if m != nil {
		return m.Hooks
	}
	return nil
}

func (m *CheckRequest) GetIssued() int64 {
	if m != nil {
		return m.Issued
	}
	return 0
}

// A ProxyRequests represents a request to execute a proxy check
type ProxyRequests struct {
	// EntityAttributes store serialized arbitrary JSON-encoded data to match
	// entities in the registry.
	EntityAttributes []string `protobuf:"bytes,1,rep,name=entity_attributes,json=entityAttributes" json:"entity_attributes"`
	// Splay indicates if proxy check requests should be splayed, published evenly
	// over a window of time.
	Splay bool `protobuf:"varint,2,opt,name=splay,proto3" json:"splay,omitempty"`
	// SplayCoverage is the percentage used for proxy check request splay
	// calculation.
	SplayCoverage uint32 `protobuf:"varint,3,opt,name=splay_coverage,json=splayCoverage,proto3" json:"splay_coverage,omitempty"`
}

func (m *ProxyRequests) Reset()                    { *m = ProxyRequests{} }
func (m *ProxyRequests) String() string            { return proto.CompactTextString(m) }
func (*ProxyRequests) ProtoMessage()               {}
func (*ProxyRequests) Descriptor() ([]byte, []int) { return fileDescriptorCheck, []int{1} }

func (m *ProxyRequests) GetEntityAttributes() []string {
	if m != nil {
		return m.EntityAttributes
	}
	return nil
}

func (m *ProxyRequests) GetSplay() bool {
	if m != nil {
		return m.Splay
	}
	return false
}

func (m *ProxyRequests) GetSplayCoverage() uint32 {
	if m != nil {
		return m.SplayCoverage
	}
	return 0
}

// CheckConfig is the specification of a check.
type CheckConfig struct {
	// Command is the command to be executed.
	Command string `protobuf:"bytes,1,opt,name=command,proto3" json:"command,omitempty"`
	// Environment indicates to which env a check belongs to
	Environment string `protobuf:"bytes,2,opt,name=environment,proto3" json:"environment,omitempty"`
	// Handlers are the event handler for the check (incidents and/or metrics).
	Handlers []string `protobuf:"bytes,3,rep,name=handlers" json:"handlers"`
	// HighFlapThreshold is the flap detection high threshold (% state change) for
	// the check. Sensu uses the same flap detection algorithm as Nagios.
	HighFlapThreshold uint32 `protobuf:"varint,4,opt,name=high_flap_threshold,json=highFlapThreshold,proto3" json:"high_flap_threshold,omitempty"`
	// Interval is the interval, in seconds, at which the check should be run.
	Interval uint32 `protobuf:"varint,5,opt,name=interval,proto3" json:"interval,omitempty"`
	// LowFlapThreshold is the flap detection low threshold (% state change) for
	// the check. Sensu uses the same flap detection algorithm as Nagios.
	LowFlapThreshold uint32 `protobuf:"varint,6,opt,name=low_flap_threshold,json=lowFlapThreshold,proto3" json:"low_flap_threshold,omitempty"`
	// Name is the unique identifier for a check.
	Name string `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty"`
	// Organization indicates to which org a check belongs to
	Organization string `protobuf:"bytes,8,opt,name=organization,proto3" json:"organization,omitempty"`
	// Publish indicates if check requests are published for the check
	Publish bool `protobuf:"varint,9,opt,name=publish,proto3" json:"publish,omitempty"`
	// RuntimeAssets are a list of assets required to execute check.
	RuntimeAssets []string `protobuf:"bytes,10,rep,name=runtime_assets,json=runtimeAssets" json:"runtime_assets"`
	// Subscriptions is the list of subscribers for the check.
	Subscriptions []string `protobuf:"bytes,11,rep,name=subscriptions" json:"subscriptions"`
	// ExtendedAttributes store serialized arbitrary JSON-encoded data
	ExtendedAttributes []byte `protobuf:"bytes,12,opt,name=ExtendedAttributes,proto3" json:"-"`
	// Sources indicates the name of the entity representing an external resource
	ProxyEntityID string `protobuf:"bytes,13,opt,name=proxy_entity_id,json=proxyEntityId,proto3" json:"proxy_entity_id"`
	// CheckHooks is the list of check hooks for the check
	CheckHooks []HookList `protobuf:"bytes,14,rep,name=check_hooks,json=checkHooks" json:"check_hooks"`
	// STDIN indicates if the check command accepts JSON via stdin from the agent
	Stdin bool `protobuf:"varint,15,opt,name=stdin,proto3" json:"stdin,omitempty"`
	// Subdue represents one or more time windows when the check should be subdued.
	Subdue *TimeWindowWhen `protobuf:"bytes,16,opt,name=subdue" json:"subdue"`
	// Cron is the cron string at which the check should be run.
	Cron string `protobuf:"bytes,17,opt,name=cron,proto3" json:"cron,omitempty"`
	// TTL represents the length of time in seconds for which a check result is valid.
	Ttl int64 `protobuf:"varint,18,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// Timeout is the timeout, in seconds, at which the check has to run
	Timeout uint32 `protobuf:"varint,19,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// ProxyRequests represents a request to execute a proxy check
	ProxyRequests *ProxyRequests `protobuf:"bytes,20,opt,name=proxy_requests,json=proxyRequests" json:"proxy_requests,omitempty"`
	// RoundRobin enables round-robin scheduling if set true.
	RoundRobin bool `protobuf:"varint,21,opt,name=round_robin,json=roundRobin,proto3" json:"round_robin,omitempty"`
	// MetricFormat is the metric protocol that the check's output will be
	// expected to follow in order to be extracted.
	MetricFormat string `protobuf:"bytes,22,opt,name=metric_format,json=metricFormat,proto3" json:"metric_format,omitempty"`
	// MetricHandlers is the list of event handlers that will respond to metrics
	// that have been extracted from the check.
	MetricHandlers []string `protobuf:"bytes,23,rep,name=metric_handlers,json=metricHandlers" json:"metric_handlers"`
}

func (m *CheckConfig) Reset()                    { *m = CheckConfig{} }
func (m *CheckConfig) String() string            { return proto.CompactTextString(m) }
func (*CheckConfig) ProtoMessage()               {}
func (*CheckConfig) Descriptor() ([]byte, []int) { return fileDescriptorCheck, []int{2} }

func (m *CheckConfig) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *CheckConfig) GetEnvironment() string {
	if m != nil {
		return m.Environment
	}
	return ""
}

func (m *CheckConfig) GetHandlers() []string {
	if m != nil {
		return m.Handlers
	}
	return nil
}

func (m *CheckConfig) GetHighFlapThreshold() uint32 {
	if m != nil {
		return m.HighFlapThreshold
	}
	return 0
}

func (m *CheckConfig) GetInterval() uint32 {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *CheckConfig) GetLowFlapThreshold() uint32 {
	if m != nil {
		return m.LowFlapThreshold
	}
	return 0
}

func (m *CheckConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CheckConfig) GetOrganization() string {
	if m != nil {
		return m.Organization
	}
	return ""
}

func (m *CheckConfig) GetPublish() bool {
	if m != nil {
		return m.Publish
	}
	return false
}

func (m *CheckConfig) GetRuntimeAssets() []string {
	if m != nil {
		return m.RuntimeAssets
	}
	return nil
}

func (m *CheckConfig) GetSubscriptions() []string {
	if m != nil {
		return m.Subscriptions
	}
	return nil
}

func (m *CheckConfig) GetExtendedAttributes() []byte {
	if m != nil {
		return m.ExtendedAttributes
	}
	return nil
}

func (m *CheckConfig) GetProxyEntityID() string {
	if m != nil {
		return m.ProxyEntityID
	}
	return ""
}

func (m *CheckConfig) GetCheckHooks() []HookList {
	if m != nil {
		return m.CheckHooks
	}
	return nil
}

func (m *CheckConfig) GetStdin() bool {
	if m != nil {
		return m.Stdin
	}
	return false
}

func (m *CheckConfig) GetSubdue() *TimeWindowWhen {
	if m != nil {
		return m.Subdue
	}
	return nil
}

func (m *CheckConfig) GetCron() string {
	if m != nil {
		return m.Cron
	}
	return ""
}

func (m *CheckConfig) GetTtl() int64 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *CheckConfig) GetTimeout() uint32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *CheckConfig) GetProxyRequests() *ProxyRequests {
	if m != nil {
		return m.ProxyRequests
	}
	return nil
}

func (m *CheckConfig) GetRoundRobin() bool {
	if m != nil {
		return m.RoundRobin
	}
	return false
}

func (m *CheckConfig) GetMetricFormat() string {
	if m != nil {
		return m.MetricFormat
	}
	return ""
}

func (m *CheckConfig) GetMetricHandlers() []string {
	if m != nil {
		return m.MetricHandlers
	}
	return nil
}

// A Check is a check specification and optionally the results of the check's
// execution.
type Check struct {
	// Command is the command to be executed.
	Command string `protobuf:"bytes,1,opt,name=command,proto3" json:"command,omitempty"`
	// Environment indicates to which env a check belongs to
	Environment string `protobuf:"bytes,2,opt,name=environment,proto3" json:"environment,omitempty"`
	// Handlers are the event handler for the check (incidents and/or metrics).
	Handlers []string `protobuf:"bytes,3,rep,name=handlers" json:"handlers"`
	// HighFlapThreshold is the flap detection high threshold (% state change) for
	// the check. Sensu uses the same flap detection algorithm as Nagios.
	HighFlapThreshold uint32 `protobuf:"varint,4,opt,name=high_flap_threshold,json=highFlapThreshold,proto3" json:"high_flap_threshold,omitempty"`
	// Interval is the interval, in seconds, at which the check should be run.
	Interval uint32 `protobuf:"varint,5,opt,name=interval,proto3" json:"interval,omitempty"`
	// LowFlapThreshold is the flap detection low threshold (% state change) for
	// the check. Sensu uses the same flap detection algorithm as Nagios.
	LowFlapThreshold uint32 `protobuf:"varint,6,opt,name=low_flap_threshold,json=lowFlapThreshold,proto3" json:"low_flap_threshold,omitempty"`
	// Name is the unique identifier for a check.
	Name string `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty"`
	// Organization indicates to which org a check belongs to
	Organization string `protobuf:"bytes,8,opt,name=organization,proto3" json:"organization,omitempty"`
	// Publish indicates if check requests are published for the check
	Publish bool `protobuf:"varint,9,opt,name=publish,proto3" json:"publish,omitempty"`
	// RuntimeAssets are a list of assets required to execute check.
	RuntimeAssets []string `protobuf:"bytes,10,rep,name=runtime_assets,json=runtimeAssets" json:"runtime_assets"`
	// Subscriptions is the list of subscribers for the check.
	Subscriptions []string `protobuf:"bytes,11,rep,name=subscriptions" json:"subscriptions"`
	// Sources indicates the name of the entity representing an external resource
	ProxyEntityID string `protobuf:"bytes,13,opt,name=proxy_entity_id,json=proxyEntityId,proto3" json:"proxy_entity_id"`
	// CheckHooks is the list of check hooks for the check
	CheckHooks []HookList `protobuf:"bytes,14,rep,name=check_hooks,json=checkHooks" json:"check_hooks"`
	// STDIN indicates if the check command accepts JSON via stdin from the agent
	Stdin bool `protobuf:"varint,15,opt,name=stdin,proto3" json:"stdin,omitempty"`
	// Subdue represents one or more time windows when the check should be subdued.
	Subdue *TimeWindowWhen `protobuf:"bytes,16,opt,name=subdue" json:"subdue"`
	// Cron is the cron string at which the check should be run.
	Cron string `protobuf:"bytes,17,opt,name=cron,proto3" json:"cron,omitempty"`
	// TTL represents the length of time in seconds for which a check result is valid.
	Ttl int64 `protobuf:"varint,18,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// Timeout is the timeout, in seconds, at which the check has to run
	Timeout uint32 `protobuf:"varint,19,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// ProxyRequests represents a request to execute a proxy check
	ProxyRequests *ProxyRequests `protobuf:"bytes,20,opt,name=proxy_requests,json=proxyRequests" json:"proxy_requests,omitempty"`
	// RoundRobin enables round-robin scheduling if set true.
	RoundRobin bool `protobuf:"varint,21,opt,name=round_robin,json=roundRobin,proto3" json:"round_robin,omitempty"`
	// Duration of execution
	Duration float64 `protobuf:"fixed64,22,opt,name=duration,proto3" json:"duration,omitempty"`
	// Executed describes the time in which the check request was executed
	Executed int64 `protobuf:"varint,23,opt,name=executed,proto3" json:"executed,omitempty"`
	// History is the check state history.
	History []CheckHistory `protobuf:"bytes,24,rep,name=history" json:"history"`
	// Issued describes the time in which the check request was issued
	Issued int64 `protobuf:"varint,25,opt,name=issued,proto3" json:"issued"`
	// Output from the execution of Command
	Output string `protobuf:"bytes,26,opt,name=output,proto3" json:"output,omitempty"`
	// State provides handlers with more information about the state change
	State string `protobuf:"bytes,27,opt,name=state,proto3" json:"state,omitempty"`
	// Status is the exit status code produced by the check
	Status uint32 `protobuf:"varint,28,opt,name=status,proto3" json:"status,omitempty"`
	// TotalStateChange indicates the total state change percentage for the
	// check's history
	TotalStateChange uint32 `protobuf:"varint,29,opt,name=total_state_change,json=totalStateChange,proto3" json:"total_state_change,omitempty"`
	// LastOK displays last time this check was ok; if event status is 0 this is set to timestamp
	LastOK int64 `protobuf:"varint,30,opt,name=last_ok,json=lastOk,proto3" json:"last_ok,omitempty"`
	// Occurrences indicates the number of times an event has occurred for a client/check pair with the same check status
	Occurrences int64 `protobuf:"varint,31,opt,name=occurrences,proto3" json:"occurrences,omitempty"`
	// OccurrencesWatermark indicates the high water mark tracking number of occurrences at the current severity
	OccurrencesWatermark int64 `protobuf:"varint,32,opt,name=occurrences_watermark,json=occurrencesWatermark,proto3" json:"occurrences_watermark,omitempty"`
	// Silenced is a list of silenced entry ids (subscription and check name)
	Silenced []string `protobuf:"bytes,33,rep,name=silenced" json:"silenced,omitempty"`
	// Hooks describes the results of multiple hooks; if event is associated to hook execution.
	Hooks []*Hook `protobuf:"bytes,34,rep,name=hooks" json:"hooks,omitempty"`
	// MetricFormat is the metric protocol that the check's output will be
	// expected to follow in order to be extracted.
	MetricFormat string `protobuf:"bytes,35,opt,name=metric_format,json=metricFormat,proto3" json:"metric_format,omitempty"`
	// MetricHandlers is the list of event handlers that will respond to metrics
	// that have been extracted from the check.
	MetricHandlers []string `protobuf:"bytes,36,rep,name=metric_handlers,json=metricHandlers" json:"metric_handlers"`
	// ExtendedAttributes store serialized arbitrary JSON-encoded data
	ExtendedAttributes []byte `protobuf:"bytes,99,opt,name=ExtendedAttributes,proto3" json:"-"`
}

func (m *Check) Reset()                    { *m = Check{} }
func (m *Check) String() string            { return proto.CompactTextString(m) }
func (*Check) ProtoMessage()               {}
func (*Check) Descriptor() ([]byte, []int) { return fileDescriptorCheck, []int{3} }

func (m *Check) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *Check) GetEnvironment() string {
	if m != nil {
		return m.Environment
	}
	return ""
}

func (m *Check) GetHandlers() []string {
	if m != nil {
		return m.Handlers
	}
	return nil
}

func (m *Check) GetHighFlapThreshold() uint32 {
	if m != nil {
		return m.HighFlapThreshold
	}
	return 0
}

func (m *Check) GetInterval() uint32 {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *Check) GetLowFlapThreshold() uint32 {
	if m != nil {
		return m.LowFlapThreshold
	}
	return 0
}

func (m *Check) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Check) GetOrganization() string {
	if m != nil {
		return m.Organization
	}
	return ""
}

func (m *Check) GetPublish() bool {
	if m != nil {
		return m.Publish
	}
	return false
}

func (m *Check) GetRuntimeAssets() []string {
	if m != nil {
		return m.RuntimeAssets
	}
	return nil
}

func (m *Check) GetSubscriptions() []string {
	if m != nil {
		return m.Subscriptions
	}
	return nil
}

func (m *Check) GetProxyEntityID() string {
	if m != nil {
		return m.ProxyEntityID
	}
	return ""
}

func (m *Check) GetCheckHooks() []HookList {
	if m != nil {
		return m.CheckHooks
	}
	return nil
}

func (m *Check) GetStdin() bool {
	if m != nil {
		return m.Stdin
	}
	return false
}

func (m *Check) GetSubdue() *TimeWindowWhen {
	if m != nil {
		return m.Subdue
	}
	return nil
}

func (m *Check) GetCron() string {
	if m != nil {
		return m.Cron
	}
	return ""
}

func (m *Check) GetTtl() int64 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *Check) GetTimeout() uint32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *Check) GetProxyRequests() *ProxyRequests {
	if m != nil {
		return m.ProxyRequests
	}
	return nil
}

func (m *Check) GetRoundRobin() bool {
	if m != nil {
		return m.RoundRobin
	}
	return false
}

func (m *Check) GetDuration() float64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Check) GetExecuted() int64 {
	if m != nil {
		return m.Executed
	}
	return 0
}

func (m *Check) GetHistory() []CheckHistory {
	if m != nil {
		return m.History
	}
	return nil
}

func (m *Check) GetIssued() int64 {
	if m != nil {
		return m.Issued
	}
	return 0
}

func (m *Check) GetOutput() string {
	if m != nil {
		return m.Output
	}
	return ""
}

func (m *Check) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *Check) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *Check) GetTotalStateChange() uint32 {
	if m != nil {
		return m.TotalStateChange
	}
	return 0
}

func (m *Check) GetLastOK() int64 {
	if m != nil {
		return m.LastOK
	}
	return 0
}

func (m *Check) GetOccurrences() int64 {
	if m != nil {
		return m.Occurrences
	}
	return 0
}

func (m *Check) GetOccurrencesWatermark() int64 {
	if m != nil {
		return m.OccurrencesWatermark
	}
	return 0
}

func (m *Check) GetSilenced() []string {
	if m != nil {
		return m.Silenced
	}
	return nil
}

func (m *Check) GetHooks() []*Hook {
	if m != nil {
		return m.Hooks
	}
	return nil
}

func (m *Check) GetMetricFormat() string {
	if m != nil {
		return m.MetricFormat
	}
	return ""
}

func (m *Check) GetMetricHandlers() []string {
	if m != nil {
		return m.MetricHandlers
	}
	return nil
}

func (m *Check) GetExtendedAttributes() []byte {
	if m != nil {
		return m.ExtendedAttributes
	}
	return nil
}

// CheckHistory is a record of a check execution and its status
type CheckHistory struct {
	// Status is the exit status code produced by the check.
	Status uint32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// Executed describes the time in which the check request was executed
	Executed int64 `protobuf:"varint,2,opt,name=executed,proto3" json:"executed,omitempty"`
}

func (m *CheckHistory) Reset()                    { *m = CheckHistory{} }
func (m *CheckHistory) String() string            { return proto.CompactTextString(m) }
func (*CheckHistory) ProtoMessage()               {}
func (*CheckHistory) Descriptor() ([]byte, []int) { return fileDescriptorCheck, []int{4} }

func (m *CheckHistory) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *CheckHistory) GetExecuted() int64 {
	if m != nil {
		return m.Executed
	}
	return 0
}

func init() {
	proto.RegisterType((*CheckRequest)(nil), "sensu.types.CheckRequest")
	proto.RegisterType((*ProxyRequests)(nil), "sensu.types.ProxyRequests")
	proto.RegisterType((*CheckConfig)(nil), "sensu.types.CheckConfig")
	proto.RegisterType((*Check)(nil), "sensu.types.Check")
	proto.RegisterType((*CheckHistory)(nil), "sensu.types.CheckHistory")
}
func (this *CheckRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CheckRequest)
	if !ok {
		that2, ok := that.(CheckRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Config.Equal(that1.Config) {
		return false
	}
	if len(this.Assets) != len(that1.Assets) {
		return false
	}
	for i := range this.Assets {
		if !this.Assets[i].Equal(&that1.Assets[i]) {
			return false
		}
	}
	if len(this.Hooks) != len(that1.Hooks) {
		return false
	}
	for i := range this.Hooks {
		if !this.Hooks[i].Equal(&that1.Hooks[i]) {
			return false
		}
	}
	if this.Issued != that1.Issued {
		return false
	}
	return true
}
func (this *ProxyRequests) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ProxyRequests)
	if !ok {
		that2, ok := that.(ProxyRequests)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.EntityAttributes) != len(that1.EntityAttributes) {
		return false
	}
	for i := range this.EntityAttributes {
		if this.EntityAttributes[i] != that1.EntityAttributes[i] {
			return false
		}
	}
	if this.Splay != that1.Splay {
		return false
	}
	if this.SplayCoverage != that1.SplayCoverage {
		return false
	}
	return true
}
func (this *CheckConfig) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CheckConfig)
	if !ok {
		that2, ok := that.(CheckConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Command != that1.Command {
		return false
	}
	if this.Environment != that1.Environment {
		return false
	}
	if len(this.Handlers) != len(that1.Handlers) {
		return false
	}
	for i := range this.Handlers {
		if this.Handlers[i] != that1.Handlers[i] {
			return false
		}
	}
	if this.HighFlapThreshold != that1.HighFlapThreshold {
		return false
	}
	if this.Interval != that1.Interval {
		return false
	}
	if this.LowFlapThreshold != that1.LowFlapThreshold {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Organization != that1.Organization {
		return false
	}
	if this.Publish != that1.Publish {
		return false
	}
	if len(this.RuntimeAssets) != len(that1.RuntimeAssets) {
		return false
	}
	for i := range this.RuntimeAssets {
		if this.RuntimeAssets[i] != that1.RuntimeAssets[i] {
			return false
		}
	}
	if len(this.Subscriptions) != len(that1.Subscriptions) {
		return false
	}
	for i := range this.Subscriptions {
		if this.Subscriptions[i] != that1.Subscriptions[i] {
			return false
		}
	}
	if !bytes.Equal(this.ExtendedAttributes, that1.ExtendedAttributes) {
		return false
	}
	if this.ProxyEntityID != that1.ProxyEntityID {
		return false
	}
	if len(this.CheckHooks) != len(that1.CheckHooks) {
		return false
	}
	for i := range this.CheckHooks {
		if !this.CheckHooks[i].Equal(&that1.CheckHooks[i]) {
			return false
		}
	}
	if this.Stdin != that1.Stdin {
		return false
	}
	if !this.Subdue.Equal(that1.Subdue) {
		return false
	}
	if this.Cron != that1.Cron {
		return false
	}
	if this.Ttl != that1.Ttl {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if !this.ProxyRequests.Equal(that1.ProxyRequests) {
		return false
	}
	if this.RoundRobin != that1.RoundRobin {
		return false
	}
	if this.MetricFormat != that1.MetricFormat {
		return false
	}
	if len(this.MetricHandlers) != len(that1.MetricHandlers) {
		return false
	}
	for i := range this.MetricHandlers {
		if this.MetricHandlers[i] != that1.MetricHandlers[i] {
			return false
		}
	}
	return true
}
func (this *Check) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Check)
	if !ok {
		that2, ok := that.(Check)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Command != that1.Command {
		return false
	}
	if this.Environment != that1.Environment {
		return false
	}
	if len(this.Handlers) != len(that1.Handlers) {
		return false
	}
	for i := range this.Handlers {
		if this.Handlers[i] != that1.Handlers[i] {
			return false
		}
	}
	if this.HighFlapThreshold != that1.HighFlapThreshold {
		return false
	}
	if this.Interval != that1.Interval {
		return false
	}
	if this.LowFlapThreshold != that1.LowFlapThreshold {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Organization != that1.Organization {
		return false
	}
	if this.Publish != that1.Publish {
		return false
	}
	if len(this.RuntimeAssets) != len(that1.RuntimeAssets) {
		return false
	}
	for i := range this.RuntimeAssets {
		if this.RuntimeAssets[i] != that1.RuntimeAssets[i] {
			return false
		}
	}
	if len(this.Subscriptions) != len(that1.Subscriptions) {
		return false
	}
	for i := range this.Subscriptions {
		if this.Subscriptions[i] != that1.Subscriptions[i] {
			return false
		}
	}
	if this.ProxyEntityID != that1.ProxyEntityID {
		return false
	}
	if len(this.CheckHooks) != len(that1.CheckHooks) {
		return false
	}
	for i := range this.CheckHooks {
		if !this.CheckHooks[i].Equal(&that1.CheckHooks[i]) {
			return false
		}
	}
	if this.Stdin != that1.Stdin {
		return false
	}
	if !this.Subdue.Equal(that1.Subdue) {
		return false
	}
	if this.Cron != that1.Cron {
		return false
	}
	if this.Ttl != that1.Ttl {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if !this.ProxyRequests.Equal(that1.ProxyRequests) {
		return false
	}
	if this.RoundRobin != that1.RoundRobin {
		return false
	}
	if this.Duration != that1.Duration {
		return false
	}
	if this.Executed != that1.Executed {
		return false
	}
	if len(this.History) != len(that1.History) {
		return false
	}
	for i := range this.History {
		if !this.History[i].Equal(&that1.History[i]) {
			return false
		}
	}
	if this.Issued != that1.Issued {
		return false
	}
	if this.Output != that1.Output {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.TotalStateChange != that1.TotalStateChange {
		return false
	}
	if this.LastOK != that1.LastOK {
		return false
	}
	if this.Occurrences != that1.Occurrences {
		return false
	}
	if this.OccurrencesWatermark != that1.OccurrencesWatermark {
		return false
	}
	if len(this.Silenced) != len(that1.Silenced) {
		return false
	}
	for i := range this.Silenced {
		if this.Silenced[i] != that1.Silenced[i] {
			return false
		}
	}
	if len(this.Hooks) != len(that1.Hooks) {
		return false
	}
	for i := range this.Hooks {
		if !this.Hooks[i].Equal(that1.Hooks[i]) {
			return false
		}
	}
	if this.MetricFormat != that1.MetricFormat {
		return false
	}
	if len(this.MetricHandlers) != len(that1.MetricHandlers) {
		return false
	}
	for i := range this.MetricHandlers {
		if this.MetricHandlers[i] != that1.MetricHandlers[i] {
			return false
		}
	}
	if !bytes.Equal(this.ExtendedAttributes, that1.ExtendedAttributes) {
		return false
	}
	return true
}
func (this *CheckHistory) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CheckHistory)
	if !ok {
		that2, ok := that.(CheckHistory)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Executed != that1.Executed {
		return false
	}
	return true
}
func (m *CheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Config.Size()))
		n1, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Assets) > 0 {
		for _, msg := range m.Assets {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCheck(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Hooks) > 0 {
		for _, msg := range m.Hooks {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCheck(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Issued != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Issued))
	}
	return i, nil
}

func (m *ProxyRequests) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyRequests) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EntityAttributes) > 0 {
		for _, s := range m.EntityAttributes {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Splay {
		dAtA[i] = 0x10
		i++
		if m.Splay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SplayCoverage != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.SplayCoverage))
	}
	return i, nil
}

func (m *CheckConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Command) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.Command)))
		i += copy(dAtA[i:], m.Command)
	}
	if len(m.Environment) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.Environment)))
		i += copy(dAtA[i:], m.Environment)
	}
	if len(m.Handlers) > 0 {
		for _, s := range m.Handlers {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.HighFlapThreshold != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.HighFlapThreshold))
	}
	if m.Interval != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Interval))
	}
	if m.LowFlapThreshold != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.LowFlapThreshold))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Organization) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.Organization)))
		i += copy(dAtA[i:], m.Organization)
	}
	if m.Publish {
		dAtA[i] = 0x48
		i++
		if m.Publish {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.RuntimeAssets) > 0 {
		for _, s := range m.RuntimeAssets {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Subscriptions) > 0 {
		for _, s := range m.Subscriptions {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ExtendedAttributes) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.ExtendedAttributes)))
		i += copy(dAtA[i:], m.ExtendedAttributes)
	}
	if len(m.ProxyEntityID) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.ProxyEntityID)))
		i += copy(dAtA[i:], m.ProxyEntityID)
	}
	if len(m.CheckHooks) > 0 {
		for _, msg := range m.CheckHooks {
			dAtA[i] = 0x72
			i++
			i = encodeVarintCheck(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Stdin {
		dAtA[i] = 0x78
		i++
		if m.Stdin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Subdue != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Subdue.Size()))
		n2, err := m.Subdue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Cron) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.Cron)))
		i += copy(dAtA[i:], m.Cron)
	}
	if m.Ttl != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Ttl))
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Timeout))
	}
	if m.ProxyRequests != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.ProxyRequests.Size()))
		n3, err := m.ProxyRequests.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.RoundRobin {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		if m.RoundRobin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.MetricFormat) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.MetricFormat)))
		i += copy(dAtA[i:], m.MetricFormat)
	}
	if len(m.MetricHandlers) > 0 {
		for _, s := range m.MetricHandlers {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Check) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Check) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Command) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.Command)))
		i += copy(dAtA[i:], m.Command)
	}
	if len(m.Environment) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.Environment)))
		i += copy(dAtA[i:], m.Environment)
	}
	if len(m.Handlers) > 0 {
		for _, s := range m.Handlers {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.HighFlapThreshold != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.HighFlapThreshold))
	}
	if m.Interval != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Interval))
	}
	if m.LowFlapThreshold != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.LowFlapThreshold))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Organization) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.Organization)))
		i += copy(dAtA[i:], m.Organization)
	}
	if m.Publish {
		dAtA[i] = 0x48
		i++
		if m.Publish {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.RuntimeAssets) > 0 {
		for _, s := range m.RuntimeAssets {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Subscriptions) > 0 {
		for _, s := range m.Subscriptions {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ProxyEntityID) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.ProxyEntityID)))
		i += copy(dAtA[i:], m.ProxyEntityID)
	}
	if len(m.CheckHooks) > 0 {
		for _, msg := range m.CheckHooks {
			dAtA[i] = 0x72
			i++
			i = encodeVarintCheck(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Stdin {
		dAtA[i] = 0x78
		i++
		if m.Stdin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Subdue != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Subdue.Size()))
		n4, err := m.Subdue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Cron) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.Cron)))
		i += copy(dAtA[i:], m.Cron)
	}
	if m.Ttl != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Ttl))
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Timeout))
	}
	if m.ProxyRequests != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.ProxyRequests.Size()))
		n5, err := m.ProxyRequests.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.RoundRobin {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		if m.RoundRobin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Duration != 0 {
		dAtA[i] = 0xb1
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Duration))))
		i += 8
	}
	if m.Executed != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Executed))
	}
	if len(m.History) > 0 {
		for _, msg := range m.History {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCheck(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Issued != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Issued))
	}
	if len(m.Output) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.Output)))
		i += copy(dAtA[i:], m.Output)
	}
	if len(m.State) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.Status != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Status))
	}
	if m.TotalStateChange != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.TotalStateChange))
	}
	if m.LastOK != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.LastOK))
	}
	if m.Occurrences != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Occurrences))
	}
	if m.OccurrencesWatermark != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.OccurrencesWatermark))
	}
	if len(m.Silenced) > 0 {
		for _, s := range m.Silenced {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x2
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Hooks) > 0 {
		for _, msg := range m.Hooks {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintCheck(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MetricFormat) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.MetricFormat)))
		i += copy(dAtA[i:], m.MetricFormat)
	}
	if len(m.MetricHandlers) > 0 {
		for _, s := range m.MetricHandlers {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x2
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ExtendedAttributes) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.ExtendedAttributes)))
		i += copy(dAtA[i:], m.ExtendedAttributes)
	}
	return i, nil
}

func (m *CheckHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckHistory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Status))
	}
	if m.Executed != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Executed))
	}
	return i, nil
}

func encodeVarintCheck(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedCheckRequest(r randyCheck, easy bool) *CheckRequest {
	this := &CheckRequest{}
	if r.Intn(10) != 0 {
		this.Config = NewPopulatedCheckConfig(r, easy)
	}
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.Assets = make([]Asset, v1)
		for i := 0; i < v1; i++ {
			v2 := NewPopulatedAsset(r, easy)
			this.Assets[i] = *v2
		}
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(5)
		this.Hooks = make([]HookConfig, v3)
		for i := 0; i < v3; i++ {
			v4 := NewPopulatedHookConfig(r, easy)
			this.Hooks[i] = *v4
		}
	}
	this.Issued = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Issued *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedProxyRequests(r randyCheck, easy bool) *ProxyRequests {
	this := &ProxyRequests{}
	v5 := r.Intn(10)
	this.EntityAttributes = make([]string, v5)
	for i := 0; i < v5; i++ {
		this.EntityAttributes[i] = string(randStringCheck(r))
	}
	this.Splay = bool(bool(r.Intn(2) == 0))
	this.SplayCoverage = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheckConfig(r randyCheck, easy bool) *CheckConfig {
	this := &CheckConfig{}
	this.Command = string(randStringCheck(r))
	this.Environment = string(randStringCheck(r))
	v6 := r.Intn(10)
	this.Handlers = make([]string, v6)
	for i := 0; i < v6; i++ {
		this.Handlers[i] = string(randStringCheck(r))
	}
	this.HighFlapThreshold = uint32(r.Uint32())
	this.Interval = uint32(r.Uint32())
	this.LowFlapThreshold = uint32(r.Uint32())
	this.Name = string(randStringCheck(r))
	this.Organization = string(randStringCheck(r))
	this.Publish = bool(bool(r.Intn(2) == 0))
	v7 := r.Intn(10)
	this.RuntimeAssets = make([]string, v7)
	for i := 0; i < v7; i++ {
		this.RuntimeAssets[i] = string(randStringCheck(r))
	}
	v8 := r.Intn(10)
	this.Subscriptions = make([]string, v8)
	for i := 0; i < v8; i++ {
		this.Subscriptions[i] = string(randStringCheck(r))
	}
	v9 := r.Intn(100)
	this.ExtendedAttributes = make([]byte, v9)
	for i := 0; i < v9; i++ {
		this.ExtendedAttributes[i] = byte(r.Intn(256))
	}
	this.ProxyEntityID = string(randStringCheck(r))
	if r.Intn(10) != 0 {
		v10 := r.Intn(5)
		this.CheckHooks = make([]HookList, v10)
		for i := 0; i < v10; i++ {
			v11 := NewPopulatedHookList(r, easy)
			this.CheckHooks[i] = *v11
		}
	}
	this.Stdin = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		this.Subdue = NewPopulatedTimeWindowWhen(r, easy)
	}
	this.Cron = string(randStringCheck(r))
	this.Ttl = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Ttl *= -1
	}
	this.Timeout = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		this.ProxyRequests = NewPopulatedProxyRequests(r, easy)
	}
	this.RoundRobin = bool(bool(r.Intn(2) == 0))
	this.MetricFormat = string(randStringCheck(r))
	v12 := r.Intn(10)
	this.MetricHandlers = make([]string, v12)
	for i := 0; i < v12; i++ {
		this.MetricHandlers[i] = string(randStringCheck(r))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheck(r randyCheck, easy bool) *Check {
	this := &Check{}
	this.Command = string(randStringCheck(r))
	this.Environment = string(randStringCheck(r))
	v13 := r.Intn(10)
	this.Handlers = make([]string, v13)
	for i := 0; i < v13; i++ {
		this.Handlers[i] = string(randStringCheck(r))
	}
	this.HighFlapThreshold = uint32(r.Uint32())
	this.Interval = uint32(r.Uint32())
	this.LowFlapThreshold = uint32(r.Uint32())
	this.Name = string(randStringCheck(r))
	this.Organization = string(randStringCheck(r))
	this.Publish = bool(bool(r.Intn(2) == 0))
	v14 := r.Intn(10)
	this.RuntimeAssets = make([]string, v14)
	for i := 0; i < v14; i++ {
		this.RuntimeAssets[i] = string(randStringCheck(r))
	}
	v15 := r.Intn(10)
	this.Subscriptions = make([]string, v15)
	for i := 0; i < v15; i++ {
		this.Subscriptions[i] = string(randStringCheck(r))
	}
	this.ProxyEntityID = string(randStringCheck(r))
	if r.Intn(10) != 0 {
		v16 := r.Intn(5)
		this.CheckHooks = make([]HookList, v16)
		for i := 0; i < v16; i++ {
			v17 := NewPopulatedHookList(r, easy)
			this.CheckHooks[i] = *v17
		}
	}
	this.Stdin = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		this.Subdue = NewPopulatedTimeWindowWhen(r, easy)
	}
	this.Cron = string(randStringCheck(r))
	this.Ttl = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Ttl *= -1
	}
	this.Timeout = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		this.ProxyRequests = NewPopulatedProxyRequests(r, easy)
	}
	this.RoundRobin = bool(bool(r.Intn(2) == 0))
	this.Duration = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Duration *= -1
	}
	this.Executed = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Executed *= -1
	}
	if r.Intn(10) != 0 {
		v18 := r.Intn(5)
		this.History = make([]CheckHistory, v18)
		for i := 0; i < v18; i++ {
			v19 := NewPopulatedCheckHistory(r, easy)
			this.History[i] = *v19
		}
	}
	this.Issued = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Issued *= -1
	}
	this.Output = string(randStringCheck(r))
	this.State = string(randStringCheck(r))
	this.Status = uint32(r.Uint32())
	this.TotalStateChange = uint32(r.Uint32())
	this.LastOK = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.LastOK *= -1
	}
	this.Occurrences = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Occurrences *= -1
	}
	this.OccurrencesWatermark = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.OccurrencesWatermark *= -1
	}
	v20 := r.Intn(10)
	this.Silenced = make([]string, v20)
	for i := 0; i < v20; i++ {
		this.Silenced[i] = string(randStringCheck(r))
	}
	if r.Intn(10) != 0 {
		v21 := r.Intn(5)
		this.Hooks = make([]*Hook, v21)
		for i := 0; i < v21; i++ {
			this.Hooks[i] = NewPopulatedHook(r, easy)
		}
	}
	this.MetricFormat = string(randStringCheck(r))
	v22 := r.Intn(10)
	this.MetricHandlers = make([]string, v22)
	for i := 0; i < v22; i++ {
		this.MetricHandlers[i] = string(randStringCheck(r))
	}
	v23 := r.Intn(100)
	this.ExtendedAttributes = make([]byte, v23)
	for i := 0; i < v23; i++ {
		this.ExtendedAttributes[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheckHistory(r randyCheck, easy bool) *CheckHistory {
	this := &CheckHistory{}
	this.Status = uint32(r.Uint32())
	this.Executed = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Executed *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyCheck interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneCheck(r randyCheck) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringCheck(r randyCheck) string {
	v24 := r.Intn(100)
	tmps := make([]rune, v24)
	for i := 0; i < v24; i++ {
		tmps[i] = randUTF8RuneCheck(r)
	}
	return string(tmps)
}
func randUnrecognizedCheck(r randyCheck, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldCheck(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldCheck(dAtA []byte, r randyCheck, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateCheck(dAtA, uint64(key))
		v25 := r.Int63()
		if r.Intn(2) == 0 {
			v25 *= -1
		}
		dAtA = encodeVarintPopulateCheck(dAtA, uint64(v25))
	case 1:
		dAtA = encodeVarintPopulateCheck(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateCheck(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateCheck(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateCheck(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateCheck(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *CheckRequest) Size() (n int) {
	var l int
	_ = l
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovCheck(uint64(l))
	}
	if len(m.Assets) > 0 {
		for _, e := range m.Assets {
			l = e.Size()
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if len(m.Hooks) > 0 {
		for _, e := range m.Hooks {
			l = e.Size()
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if m.Issued != 0 {
		n += 1 + sovCheck(uint64(m.Issued))
	}
	return n
}

func (m *ProxyRequests) Size() (n int) {
	var l int
	_ = l
	if len(m.EntityAttributes) > 0 {
		for _, s := range m.EntityAttributes {
			l = len(s)
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if m.Splay {
		n += 2
	}
	if m.SplayCoverage != 0 {
		n += 1 + sovCheck(uint64(m.SplayCoverage))
	}
	return n
}

func (m *CheckConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovCheck(uint64(l))
	}
	l = len(m.Environment)
	if l > 0 {
		n += 1 + l + sovCheck(uint64(l))
	}
	if len(m.Handlers) > 0 {
		for _, s := range m.Handlers {
			l = len(s)
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if m.HighFlapThreshold != 0 {
		n += 1 + sovCheck(uint64(m.HighFlapThreshold))
	}
	if m.Interval != 0 {
		n += 1 + sovCheck(uint64(m.Interval))
	}
	if m.LowFlapThreshold != 0 {
		n += 1 + sovCheck(uint64(m.LowFlapThreshold))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCheck(uint64(l))
	}
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovCheck(uint64(l))
	}
	if m.Publish {
		n += 2
	}
	if len(m.RuntimeAssets) > 0 {
		for _, s := range m.RuntimeAssets {
			l = len(s)
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if len(m.Subscriptions) > 0 {
		for _, s := range m.Subscriptions {
			l = len(s)
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	l = len(m.ExtendedAttributes)
	if l > 0 {
		n += 1 + l + sovCheck(uint64(l))
	}
	l = len(m.ProxyEntityID)
	if l > 0 {
		n += 1 + l + sovCheck(uint64(l))
	}
	if len(m.CheckHooks) > 0 {
		for _, e := range m.CheckHooks {
			l = e.Size()
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if m.Stdin {
		n += 2
	}
	if m.Subdue != nil {
		l = m.Subdue.Size()
		n += 2 + l + sovCheck(uint64(l))
	}
	l = len(m.Cron)
	if l > 0 {
		n += 2 + l + sovCheck(uint64(l))
	}
	if m.Ttl != 0 {
		n += 2 + sovCheck(uint64(m.Ttl))
	}
	if m.Timeout != 0 {
		n += 2 + sovCheck(uint64(m.Timeout))
	}
	if m.ProxyRequests != nil {
		l = m.ProxyRequests.Size()
		n += 2 + l + sovCheck(uint64(l))
	}
	if m.RoundRobin {
		n += 3
	}
	l = len(m.MetricFormat)
	if l > 0 {
		n += 2 + l + sovCheck(uint64(l))
	}
	if len(m.MetricHandlers) > 0 {
		for _, s := range m.MetricHandlers {
			l = len(s)
			n += 2 + l + sovCheck(uint64(l))
		}
	}
	return n
}

func (m *Check) Size() (n int) {
	var l int
	_ = l
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovCheck(uint64(l))
	}
	l = len(m.Environment)
	if l > 0 {
		n += 1 + l + sovCheck(uint64(l))
	}
	if len(m.Handlers) > 0 {
		for _, s := range m.Handlers {
			l = len(s)
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if m.HighFlapThreshold != 0 {
		n += 1 + sovCheck(uint64(m.HighFlapThreshold))
	}
	if m.Interval != 0 {
		n += 1 + sovCheck(uint64(m.Interval))
	}
	if m.LowFlapThreshold != 0 {
		n += 1 + sovCheck(uint64(m.LowFlapThreshold))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCheck(uint64(l))
	}
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovCheck(uint64(l))
	}
	if m.Publish {
		n += 2
	}
	if len(m.RuntimeAssets) > 0 {
		for _, s := range m.RuntimeAssets {
			l = len(s)
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if len(m.Subscriptions) > 0 {
		for _, s := range m.Subscriptions {
			l = len(s)
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	l = len(m.ProxyEntityID)
	if l > 0 {
		n += 1 + l + sovCheck(uint64(l))
	}
	if len(m.CheckHooks) > 0 {
		for _, e := range m.CheckHooks {
			l = e.Size()
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if m.Stdin {
		n += 2
	}
	if m.Subdue != nil {
		l = m.Subdue.Size()
		n += 2 + l + sovCheck(uint64(l))
	}
	l = len(m.Cron)
	if l > 0 {
		n += 2 + l + sovCheck(uint64(l))
	}
	if m.Ttl != 0 {
		n += 2 + sovCheck(uint64(m.Ttl))
	}
	if m.Timeout != 0 {
		n += 2 + sovCheck(uint64(m.Timeout))
	}
	if m.ProxyRequests != nil {
		l = m.ProxyRequests.Size()
		n += 2 + l + sovCheck(uint64(l))
	}
	if m.RoundRobin {
		n += 3
	}
	if m.Duration != 0 {
		n += 10
	}
	if m.Executed != 0 {
		n += 2 + sovCheck(uint64(m.Executed))
	}
	if len(m.History) > 0 {
		for _, e := range m.History {
			l = e.Size()
			n += 2 + l + sovCheck(uint64(l))
		}
	}
	if m.Issued != 0 {
		n += 2 + sovCheck(uint64(m.Issued))
	}
	l = len(m.Output)
	if l > 0 {
		n += 2 + l + sovCheck(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 2 + l + sovCheck(uint64(l))
	}
	if m.Status != 0 {
		n += 2 + sovCheck(uint64(m.Status))
	}
	if m.TotalStateChange != 0 {
		n += 2 + sovCheck(uint64(m.TotalStateChange))
	}
	if m.LastOK != 0 {
		n += 2 + sovCheck(uint64(m.LastOK))
	}
	if m.Occurrences != 0 {
		n += 2 + sovCheck(uint64(m.Occurrences))
	}
	if m.OccurrencesWatermark != 0 {
		n += 2 + sovCheck(uint64(m.OccurrencesWatermark))
	}
	if len(m.Silenced) > 0 {
		for _, s := range m.Silenced {
			l = len(s)
			n += 2 + l + sovCheck(uint64(l))
		}
	}
	if len(m.Hooks) > 0 {
		for _, e := range m.Hooks {
			l = e.Size()
			n += 2 + l + sovCheck(uint64(l))
		}
	}
	l = len(m.MetricFormat)
	if l > 0 {
		n += 2 + l + sovCheck(uint64(l))
	}
	if len(m.MetricHandlers) > 0 {
		for _, s := range m.MetricHandlers {
			l = len(s)
			n += 2 + l + sovCheck(uint64(l))
		}
	}
	l = len(m.ExtendedAttributes)
	if l > 0 {
		n += 2 + l + sovCheck(uint64(l))
	}
	return n
}

func (m *CheckHistory) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovCheck(uint64(m.Status))
	}
	if m.Executed != 0 {
		n += 1 + sovCheck(uint64(m.Executed))
	}
	return n
}

func sovCheck(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCheck(x uint64) (n int) {
	return sovCheck(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &CheckConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = append(m.Assets, Asset{})
			if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hooks = append(m.Hooks, HookConfig{})
			if err := m.Hooks[len(m.Hooks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issued", wireType)
			}
			m.Issued = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Issued |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxyRequests) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxyRequests: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxyRequests: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityAttributes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityAttributes = append(m.EntityAttributes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Splay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Splay = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplayCoverage", wireType)
			}
			m.SplayCoverage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SplayCoverage |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Environment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handlers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Handlers = append(m.Handlers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighFlapThreshold", wireType)
			}
			m.HighFlapThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighFlapThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowFlapThreshold", wireType)
			}
			m.LowFlapThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowFlapThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publish", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Publish = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeAssets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeAssets = append(m.RuntimeAssets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscriptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subscriptions = append(m.Subscriptions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendedAttributes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtendedAttributes = append(m.ExtendedAttributes[:0], dAtA[iNdEx:postIndex]...)
			if m.ExtendedAttributes == nil {
				m.ExtendedAttributes = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyEntityID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyEntityID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckHooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckHooks = append(m.CheckHooks, HookList{})
			if err := m.CheckHooks[len(m.CheckHooks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stdin = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subdue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subdue == nil {
				m.Subdue = &TimeWindowWhen{}
			}
			if err := m.Subdue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cron", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cron = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProxyRequests == nil {
				m.ProxyRequests = &ProxyRequests{}
			}
			if err := m.ProxyRequests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundRobin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RoundRobin = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricHandlers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricHandlers = append(m.MetricHandlers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Check) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Check: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Check: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Environment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handlers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Handlers = append(m.Handlers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighFlapThreshold", wireType)
			}
			m.HighFlapThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighFlapThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowFlapThreshold", wireType)
			}
			m.LowFlapThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowFlapThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publish", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Publish = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeAssets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeAssets = append(m.RuntimeAssets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscriptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subscriptions = append(m.Subscriptions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyEntityID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyEntityID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckHooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckHooks = append(m.CheckHooks, HookList{})
			if err := m.CheckHooks[len(m.CheckHooks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stdin = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subdue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subdue == nil {
				m.Subdue = &TimeWindowWhen{}
			}
			if err := m.Subdue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cron", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cron = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProxyRequests == nil {
				m.ProxyRequests = &ProxyRequests{}
			}
			if err := m.ProxyRequests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundRobin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RoundRobin = bool(v != 0)
		case 22:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Duration = float64(math.Float64frombits(v))
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executed", wireType)
			}
			m.Executed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Executed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field History", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.History = append(m.History, CheckHistory{})
			if err := m.History[len(m.History)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issued", wireType)
			}
			m.Issued = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Issued |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalStateChange", wireType)
			}
			m.TotalStateChange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalStateChange |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastOK", wireType)
			}
			m.LastOK = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastOK |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Occurrences", wireType)
			}
			m.Occurrences = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Occurrences |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OccurrencesWatermark", wireType)
			}
			m.OccurrencesWatermark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OccurrencesWatermark |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silenced", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Silenced = append(m.Silenced, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hooks = append(m.Hooks, &Hook{})
			if err := m.Hooks[len(m.Hooks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricHandlers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricHandlers = append(m.MetricHandlers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendedAttributes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtendedAttributes = append(m.ExtendedAttributes[:0], dAtA[iNdEx:postIndex]...)
			if m.ExtendedAttributes == nil {
				m.ExtendedAttributes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executed", wireType)
			}
			m.Executed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Executed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCheck(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCheck
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCheck
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCheck
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCheck(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCheck = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCheck   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("check.proto", fileDescriptorCheck) }

var fileDescriptorCheck = []byte{
	// 1103 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x56, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xef, 0xd6, 0xb1, 0xe3, 0x8c, 0xe3, 0x24, 0x9e, 0x24, 0xcd, 0xd4, 0x05, 0xaf, 0x71, 0x8a,
	0xe4, 0x03, 0x71, 0x51, 0x23, 0x40, 0x48, 0x48, 0x28, 0x4e, 0x5b, 0xa5, 0x6a, 0xa4, 0xa2, 0xa1,
	0x52, 0x24, 0x2e, 0xab, 0xf5, 0xee, 0xc4, 0xbb, 0xca, 0x7a, 0xc6, 0xcc, 0xcc, 0xe6, 0x0f, 0x9f,
	0x82, 0x23, 0x1f, 0x81, 0x8f, 0xc0, 0x91, 0x63, 0x8f, 0xf0, 0x05, 0x2c, 0x70, 0x6f, 0xfe, 0x04,
	0x1c, 0xd1, 0xbc, 0x19, 0x1b, 0x3b, 0x06, 0xd1, 0x23, 0x48, 0x3d, 0x79, 0x7e, 0xbf, 0xf7, 0xde,
	0xee, 0xec, 0x9b, 0xdf, 0x6f, 0xfc, 0x50, 0x25, 0x4a, 0x58, 0x74, 0xd1, 0x19, 0x4a, 0xa1, 0x05,
	0xae, 0x28, 0xc6, 0x55, 0xde, 0xd1, 0x37, 0x43, 0xa6, 0xea, 0x07, 0xfd, 0x54, 0x27, 0x79, 0xaf,
	0x13, 0x89, 0xc1, 0xa3, 0xbe, 0xe8, 0x8b, 0x47, 0x90, 0xd3, 0xcb, 0xcf, 0x01, 0x01, 0x80, 0x95,
	0xad, 0xad, 0x57, 0x42, 0xa5, 0x98, 0x76, 0x00, 0x25, 0x42, 0xb8, 0x87, 0xd6, 0x6b, 0x3a, 0x1d,
	0xb0, 0xe0, 0x2a, 0xe5, 0xb1, 0xb8, 0xb2, 0x54, 0xeb, 0x57, 0x0f, 0xad, 0x1f, 0x9b, 0xf7, 0x52,
	0xf6, 0x6d, 0xce, 0x94, 0xc6, 0x9f, 0xa2, 0x52, 0x24, 0xf8, 0x79, 0xda, 0x27, 0x5e, 0xd3, 0x6b,
	0x57, 0x1e, 0x93, 0xce, 0xdc, 0x4e, 0x3a, 0x90, 0x7a, 0x0c, 0xf1, 0xee, 0xca, 0xeb, 0x91, 0xef,
	0x51, 0x97, 0x8d, 0x3f, 0x46, 0x25, 0x78, 0xad, 0x22, 0x77, 0x9b, 0x85, 0x76, 0xe5, 0x31, 0x5e,
	0xa8, 0x3b, 0x32, 0x21, 0xa8, 0xb8, 0x43, 0x5d, 0x1e, 0x3e, 0x44, 0x45, 0xb3, 0x37, 0x45, 0x0a,
	0x50, 0xb0, 0xb7, 0x50, 0x70, 0x22, 0xc4, 0xfc, 0x7b, 0xee, 0x50, 0x9b, 0x8b, 0x5b, 0xa8, 0xf4,
	0x5c, 0xa9, 0x9c, 0xc5, 0x64, 0xa5, 0xe9, 0xb5, 0x0b, 0x5d, 0x34, 0x19, 0xf9, 0xa5, 0x14, 0x18,
	0xea, 0x22, 0xad, 0xef, 0x3d, 0x54, 0xfd, 0x4a, 0x8a, 0xeb, 0x1b, 0xf7, 0x4d, 0x0a, 0x77, 0x51,
	0x8d, 0x71, 0x9d, 0xea, 0x9b, 0x20, 0xd4, 0x5a, 0xa6, 0xbd, 0x5c, 0x33, 0x45, 0xbc, 0x66, 0xa1,
	0xbd, 0xd6, 0xdd, 0x9d, 0x8c, 0xfc, 0xe5, 0x20, 0xdd, 0xb2, 0xd4, 0xd1, 0x8c, 0xc1, 0x3b, 0xa8,
	0xa8, 0x86, 0x59, 0x78, 0x43, 0xee, 0x36, 0xbd, 0x76, 0x99, 0x5a, 0x80, 0x3f, 0x44, 0x1b, 0xb0,
	0x08, 0x22, 0x71, 0xc9, 0x64, 0xd8, 0x67, 0xa4, 0xd0, 0xf4, 0xda, 0x55, 0x5a, 0x05, 0xf6, 0xd8,
	0x91, 0xad, 0x37, 0xab, 0xa8, 0x32, 0xd7, 0x3b, 0x4c, 0xd0, 0x6a, 0x24, 0x06, 0x83, 0x90, 0xc7,
	0xd0, 0xe6, 0x35, 0x3a, 0x85, 0xb8, 0x89, 0x2a, 0x8c, 0x5f, 0xa6, 0x52, 0xf0, 0x01, 0xe3, 0x1a,
	0x5e, 0xb6, 0x46, 0xe7, 0x29, 0xdc, 0x46, 0xe5, 0x24, 0xe4, 0x71, 0xc6, 0xa4, 0x6d, 0xdd, 0x5a,
	0x77, 0x7d, 0x32, 0xf2, 0x67, 0x1c, 0x9d, 0xad, 0x70, 0x07, 0x6d, 0x27, 0x69, 0x3f, 0x09, 0xce,
	0xb3, 0x70, 0x18, 0xe8, 0x44, 0x32, 0x95, 0x88, 0xcc, 0x76, 0xae, 0x4a, 0x6b, 0x26, 0xf4, 0x2c,
	0x0b, 0x87, 0xaf, 0xa6, 0x01, 0x5c, 0x47, 0xe5, 0x94, 0x6b, 0x26, 0x2f, 0xc3, 0x8c, 0x14, 0x21,
	0x69, 0x86, 0xf1, 0x47, 0x08, 0x67, 0xe2, 0xea, 0xf6, 0xa3, 0x4a, 0x90, 0xb5, 0x95, 0x89, 0xab,
	0xc5, 0x27, 0x61, 0xb4, 0xc2, 0xc3, 0x01, 0x23, 0xab, 0xb0, 0x7d, 0x58, 0xe3, 0x16, 0x5a, 0x17,
	0xb2, 0x1f, 0xf2, 0xf4, 0xbb, 0x50, 0xa7, 0x82, 0x93, 0x32, 0xc4, 0x16, 0x38, 0xd3, 0x97, 0x61,
	0xde, 0xcb, 0x52, 0x95, 0x90, 0x35, 0x68, 0xf3, 0x14, 0xe2, 0xcf, 0xd1, 0x86, 0xcc, 0x39, 0x08,
	0xd8, 0xe9, 0x0c, 0xc1, 0xb7, 0xe3, 0xc9, 0xc8, 0xbf, 0x15, 0xa1, 0x55, 0x87, 0x8f, 0xac, 0xd0,
	0x3e, 0x43, 0x55, 0x95, 0xf7, 0x54, 0x24, 0xd3, 0xa1, 0x79, 0x89, 0x22, 0x15, 0xa8, 0xac, 0x4d,
	0x46, 0xfe, 0x62, 0x80, 0x2e, 0x42, 0xfc, 0x09, 0xc2, 0x4f, 0xaf, 0x35, 0xe3, 0x31, 0x8b, 0xff,
	0x12, 0x02, 0x59, 0x6f, 0x7a, 0xed, 0xf5, 0x6e, 0x71, 0x32, 0xf2, 0xbd, 0x03, 0xfa, 0x37, 0x09,
	0xf8, 0x14, 0x6d, 0x0e, 0x8d, 0xfc, 0x02, 0x27, 0xab, 0x34, 0x26, 0x55, 0xf3, 0xad, 0xdd, 0x87,
	0xe3, 0x91, 0x6f, 0x95, 0xf9, 0x14, 0x22, 0xcf, 0x9f, 0x4c, 0x46, 0xfe, 0xed, 0x5c, 0x5a, 0x1d,
	0xce, 0x65, 0xc4, 0xf8, 0x85, 0xbb, 0x18, 0x02, 0x6b, 0x96, 0x0d, 0x30, 0xcb, 0xee, 0x92, 0x59,
	0x4e, 0x53, 0xa5, 0xbb, 0xdb, 0xc6, 0x2a, 0x93, 0x91, 0x3f, 0x5f, 0x41, 0x11, 0x80, 0x13, 0xb0,
	0x8f, 0x11, 0xb1, 0x8e, 0x53, 0x4e, 0x36, 0x9d, 0x88, 0x0d, 0xc0, 0x5f, 0xa2, 0x92, 0xca, 0x7b,
	0x71, 0xce, 0xc8, 0x16, 0x78, 0xfe, 0xc1, 0xc2, 0xd3, 0x5f, 0xa5, 0x03, 0x76, 0x06, 0x77, 0xc6,
	0x59, 0xc2, 0xb8, 0x75, 0x9c, 0x4d, 0xa7, 0xee, 0xd7, 0x1c, 0x77, 0x24, 0x05, 0x27, 0x35, 0x7b,
	0xdc, 0x66, 0x8d, 0xb7, 0x50, 0x41, 0xeb, 0x8c, 0x60, 0x63, 0x53, 0x6a, 0x96, 0xe6, 0x70, 0xcd,
	0xa9, 0x88, 0x5c, 0x93, 0x6d, 0xd0, 0xcd, 0x14, 0xe2, 0x23, 0xb4, 0x61, 0xbb, 0x20, 0x9d, 0x63,
	0xc9, 0x0e, 0x6c, 0xa4, 0xbe, 0xb0, 0x91, 0x05, 0x4f, 0xbb, 0x36, 0xcd, 0x2c, 0xee, 0xa3, 0x8a,
	0x14, 0x39, 0x8f, 0x03, 0x29, 0x7a, 0x29, 0x27, 0xbb, 0xf0, 0x7d, 0x08, 0x28, 0x6a, 0x18, 0xbc,
	0x8f, 0xaa, 0x03, 0xa6, 0x65, 0x1a, 0x05, 0xe7, 0x42, 0x0e, 0x42, 0x4d, 0xee, 0x59, 0xfd, 0x59,
	0xf2, 0x19, 0x70, 0xf8, 0x0b, 0xb4, 0xe9, 0x92, 0x66, 0x16, 0xdb, 0x03, 0xb1, 0x6c, 0x9b, 0x93,
	0xba, 0x15, 0xa2, 0x1b, 0x96, 0x38, 0x71, 0xb8, 0xf5, 0x73, 0x05, 0x15, 0xc1, 0xe5, 0xef, 0xfc,
	0xfd, 0xbf, 0xf0, 0xf7, 0x3b, 0xa3, 0xfe, 0x17, 0x8d, 0x5a, 0x47, 0xe5, 0x38, 0x97, 0x56, 0x43,
	0xc6, 0xa3, 0x1e, 0x9d, 0x61, 0x13, 0x63, 0xd7, 0x2c, 0xca, 0x35, 0x8b, 0xc9, 0x1e, 0x6c, 0x78,
	0x86, 0xf1, 0x13, 0xb4, 0x9a, 0xa4, 0x4a, 0x0b, 0x79, 0x43, 0x08, 0xf4, 0xfe, 0xfe, 0xf2, 0xe8,
	0x72, 0x62, 0x13, 0xba, 0x9b, 0xae, 0xff, 0xd3, 0x0a, 0x3a, 0x5d, 0x98, 0x01, 0xc3, 0x8e, 0x13,
	0xe4, 0xfe, 0xf2, 0x80, 0x61, 0x7f, 0xf1, 0x3d, 0x54, 0x12, 0xb9, 0x1e, 0xe6, 0x9a, 0xd4, 0xa1,
	0x8f, 0x0e, 0xd9, 0x43, 0x0b, 0x35, 0x23, 0x0f, 0x80, 0xb6, 0xc0, 0x64, 0x9b, 0x45, 0xae, 0xc8,
	0x7b, 0xd0, 0x4c, 0x87, 0x8c, 0xe3, 0xb4, 0xd0, 0x61, 0x16, 0x40, 0x5a, 0x10, 0x25, 0x21, 0xef,
	0x33, 0xf2, 0xbe, 0x75, 0x1c, 0x44, 0xbe, 0x36, 0x81, 0x63, 0xe0, 0xf1, 0x3e, 0x5a, 0xcd, 0x42,
	0xa5, 0x03, 0x71, 0x41, 0x1a, 0x76, 0x63, 0xe3, 0x91, 0x5f, 0x3a, 0x0d, 0x95, 0x7e, 0xf9, 0x82,
	0x96, 0x4c, 0xe8, 0xe5, 0x85, 0xb9, 0x5c, 0x44, 0x14, 0xe5, 0x52, 0x32, 0x1e, 0x31, 0x45, 0x7c,
	0xe8, 0xd0, 0x3c, 0x85, 0x0f, 0xd1, 0xee, 0x1c, 0x0c, 0xae, 0x42, 0xcd, 0xe4, 0x20, 0x94, 0x17,
	0xa4, 0x09, 0xb9, 0x3b, 0x73, 0xc1, 0xb3, 0x69, 0x0c, 0x37, 0x51, 0x59, 0xa5, 0x99, 0x21, 0x63,
	0xf2, 0x01, 0x78, 0xcb, 0xce, 0x7e, 0x33, 0x16, 0x1f, 0x4c, 0x67, 0xb9, 0x16, 0x74, 0xbe, 0xb6,
	0xa4, 0x7a, 0x57, 0xe1, 0xa6, 0xb8, 0xa5, 0xbb, 0x78, 0xff, 0xed, 0xee, 0xe2, 0x87, 0x6f, 0x7d,
	0x17, 0xff, 0xc3, 0x7f, 0x77, 0xf4, 0x2f, 0xff, 0xdd, 0xad, 0xae, 0x1b, 0x87, 0x9d, 0x50, 0xe6,
	0x0e, 0xcf, 0x5b, 0x38, 0xbc, 0x79, 0x21, 0xde, 0x5d, 0x14, 0x62, 0x77, 0xff, 0x8f, 0xdf, 0x1b,
	0xde, 0x8f, 0xe3, 0x86, 0xf7, 0xd3, 0xb8, 0xe1, 0xbd, 0x1e, 0x37, 0xbc, 0x5f, 0xc6, 0x0d, 0xef,
	0xb7, 0x71, 0xc3, 0xfb, 0xe1, 0x4d, 0xe3, 0xce, 0x37, 0x45, 0x68, 0x4a, 0xaf, 0x04, 0xf3, 0xf7,
	0xe1, 0x9f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x54, 0x41, 0x3b, 0xce, 0xf6, 0x0b, 0x00, 0x00,
}
