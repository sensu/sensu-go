// +build ignore

package main

import (
	"bytes"
	"fmt"
	"html/template"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"strings"

	"github.com/mgutz/ansi"
	"github.com/shurcooL/vfsgen"
)

const filenameVfsGen = "assets_vfsgen.go"
const filenameGlueFile = "assets_glue.go"

var (
	red    = ansi.ColorFunc("red+b")
	white  = ansi.ColorFunc("white+b")
	yellow = ansi.ColorFunc("yellow+b")
)

var t = template.Must(template.New("").Parse(`// Code generated by vfsgen; DO NOT EDIT.
{{with .BuildTags}}// +build {{.}}
{{end}}
package dashboard

func init() {
	{{.PublicVariableName}} = {{.GeneratedVariableName}}
}
`))

func main() {
	if _, err := exec.LookPath("node"); err != nil {
		fmt.Println(yellow("‚ö†Ô∏è  Warning"), white("'node' was not found in your PATH, unable to bundle web UI."))
		fmt.Println(white("See https://nodejs.org/en/download/package-manager/ for installation instructions."))
		fmt.Println(white("Skipping dashboard build."))
		return
	}

	if _, err := exec.LookPath("yarn"); err != nil {
		fmt.Println(yellow("‚ö†Ô∏è  Warning"), white("'yarn' was not found in your PATH, unable to bundle web UI."))
		fmt.Println(white("See https://yarnpkg.com/en/docs/install for installation instructions."))
		fmt.Println(white("Skipping dashboard build."))
		return
	}

	// install web ui depedencies
	mustRunCmd("yarn", "install", "--verbose")

	// install web ui depedencies
	mustRunCmd("yarn", "build")

	// box files
	dir := http.Dir("build")
	err := vfsgen.Generate(dir, vfsgen.Options{
		Filename:     filenameVfsGen,
		PackageName:  "dashboard",
		BuildTags:    "!dev",
		VariableName: "vfsAssets",
	})
	if err != nil {
		log.Fatalln(err)
	}

	// glue
	buf := &bytes.Buffer{}
	t.Execute(buf, struct {
		BuildTags             string
		PublicVariableName    string
		GeneratedVariableName string
	}{
		BuildTags:             "!dev",
		PublicVariableName:    "Assets",
		GeneratedVariableName: "vfsAssets",
	})

	fmt.Printf("Writing %s\n", filenameGlueFile)
	err = ioutil.WriteFile(filenameGlueFile, buf.Bytes(), 0644)
	if err != nil {
		log.Fatalln(err)
	}
}

func mustRunCmd(pro string, args ...string) {
	buf := bytes.Buffer{}
	cmd := exec.Command(pro, args...)
	cmd.Stdout = &buf

	cmdStr := strings.Join(append([]string{pro}, args...), " ")
	fmt.Printf("Running '%s'\n", cmdStr)
	if err := cmd.Run(); err != nil {

		fmt.Println("")
		fmt.Fprint(os.Stderr, buf.String())
		fmt.Fprintf(os.Stderr, "üõë  %s %s '%s'\n", red("Error"), "failed to run", white(cmdStr))
		os.Exit(1)
	}
}
