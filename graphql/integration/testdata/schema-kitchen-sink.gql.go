// Code generated by scripts/gengraphql.go. DO NOT EDIT.

package schema

import (
	graphql1 "github.com/graphql-go/graphql"
	ast "github.com/graphql-go/graphql/language/ast"
	mapstructure "github.com/mitchellh/mapstructure"
	graphql "github.com/sensu/sensu-go/graphql"
)

// Schema supplies the root types of each type of operation, query,
// mutation (optional), and subscription (optional).
var Schema = graphql.NewType("Schema", graphql.SchemaKind)

// RegisterSchema registers schema description with given service.
func RegisterSchema(svc *graphql.Service) {
	svc.RegisterSchema(_SchemaDesc)
}
func _SchemaConfigFn() graphql1.SchemaConfig {
	return graphql1.SchemaConfig{Query: graphql.Object("QueryRoot")}
}

// describe schema's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _SchemaDesc = graphql.SchemaDesc{Config: _SchemaConfigFn}

// QueryRootFoosFieldResolver implement to resolve requests for the QueryRoot's foos field.
type QueryRootFoosFieldResolver interface {
	// Foos implements response to request for foos field.
	Foos(p graphql.ResolveParams) (interface{}, error)
}

// QueryRootMyBarFieldResolver implement to resolve requests for the QueryRoot's myBar field.
type QueryRootMyBarFieldResolver interface {
	// MyBar implements response to request for myBar field.
	MyBar(p graphql.ResolveParams) (interface{}, error)
}

//
// QueryRootFieldResolvers represents a collection of methods whose products represent the
// response values of the 'QueryRoot' type.
//
// == Example SDL
//
//   """
//   Dog's are not hooman.
//   """
//   type Dog implements Pet {
//     "name of this fine beast."
//     name:  String!
//
//     "breed of this silly animal; probably shibe."
//     breed: [Breed]
//   }
//
// == Example generated interface
//
//   // DogResolver ...
//   type DogFieldResolvers interface {
//     DogNameFieldResolver
//     DogBreedFieldResolver
//
//     // IsTypeOf is used to determine if a given value is associated with the Dog type
//     IsTypeOf(interface{}, graphql.IsTypeOfParams) bool
//   }
//
// == Example implementation ...
//
//   // DogResolver implements DogFieldResolvers interface
//   type DogResolver struct {
//     logger logrus.LogEntry
//     store interface{
//       store.BreedStore
//       store.DogStore
//     }
//   }
//
//   // Name implements response to request for name field.
//   func (r *DogResolver) Name(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     return dog.GetName()
//   }
//
//   // Breed implements response to request for breed field.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     breed := r.store.GetBreed(dog.GetBreedName())
//     return breed
//   }
//
//   // IsTypeOf is used to determine if a given value is associated with the Dog type
//   func (r *DogResolver) IsTypeOf(p graphql.IsTypeOfParams) bool {
//     // ... implementation details ...
//     _, ok := p.Value.(DogGetter)
//     return ok
//   }
//
type QueryRootFieldResolvers interface {
	QueryRootFoosFieldResolver
	QueryRootMyBarFieldResolver

	// IsTypeOf is used to determine if a given value is associated with the QueryRoot type
	IsTypeOf(interface{}, graphql.IsTypeOfParams) bool
}

// QueryRootAliases implements all methods on QueryRootFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
//
// == Example SDL
//
//    type Dog {
//      name:   String!
//      weight: Float!
//      dob:    DateTime
//      breed:  [Breed]
//    }
//
// == Example generated aliases
//
//   type DogAliases struct {}
//   func (_ DogAliases) Name(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Weight(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Dob(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//
// == Example Implementation
//
//   type DogResolver struct { // Implements DogResolver
//     DogAliases
//     store store.BreedStore
//   }
//
//   // NOTE:
//   // All other fields are satisified by DogAliases but since this one
//   // requires hitting the store we implement it in our resolver.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) interface{} {
//     dog := v.(*Dog)
//     return r.BreedsById(dog.BreedIDs)
//   }
//
type QueryRootAliases struct{}

// Foos implements response to request for 'foos' field.
func (_ QueryRootAliases) Foos(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret := val.(interface{})
	return ret, err
}

// MyBar implements response to request for 'myBar' field.
func (_ QueryRootAliases) MyBar(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret := val.(interface{})
	return ret, err
}

// QueryRootType QueryRoot is entry point for queries
var QueryRootType = graphql.NewType("QueryRoot", graphql.ObjectKind)

// RegisterQueryRoot registers QueryRoot object type with given service.
func RegisterQueryRoot(svc *graphql.Service, impl QueryRootFieldResolvers) {
	svc.RegisterObject(_ObjectTypeQueryRootDesc, impl)
}
func _ObjTypeQueryRootFoosHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(QueryRootFoosFieldResolver)
	return resolver.Foos
}

func _ObjTypeQueryRootMyBarHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(QueryRootMyBarFieldResolver)
	return resolver.MyBar
}

func _ObjectTypeQueryRootConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "QueryRoot is entry point for queries",
		Fields: graphql1.Fields{
			"foos": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "foos",
				Type:              graphql1.NewList(graphql.OutputType("Foo")),
			},
			"myBar": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "myBar",
				Type:              graphql.OutputType("Bar"),
			},
		},
		Interfaces: []*graphql1.Interface{},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see QueryRootFieldResolvers.")
		},
		Name: "QueryRoot",
	}
}

// describe QueryRoot's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeQueryRootDesc = graphql.ObjectDesc{
	Config: _ObjectTypeQueryRootConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{
		"foos":  _ObjTypeQueryRootFoosHandler,
		"myBar": _ObjTypeQueryRootMyBarHandler,
	},
}

// UrlType ... Url describes an address that points to a resource.
var UrlType = graphql.NewType("Url", graphql.ScalarKind)

// RegisterUrl registers Url object type with given service.
func RegisterUrl(svc *graphql.Service, impl graphql.ScalarResolver) {
	svc.RegisterScalar(_ScalarTypeUrlDesc, impl)
}

// describe Url's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ScalarTypeUrlDesc = graphql.ScalarDesc{Config: func() graphql1.ScalarConfig {
	return graphql1.ScalarConfig{
		Description: "Url describes an address that points to a resource.",
		Name:        "Url",
		ParseLiteral: func(_ ast.Value) interface{} {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see ScalarResolver.")
		},
		ParseValue: func(_ interface{}) interface{} {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see ScalarResolver.")
		},
		Serialize: func(_ interface{}) interface{} {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see ScalarResolver.")
		},
	}
}}

// FooOneFieldResolver implement to resolve requests for the Foo's one field.
type FooOneFieldResolver interface {
	// One implements response to request for one field.
	One(p graphql.ResolveParams) (interface{}, error)
}

// FooTwoFieldResolverArgs contains arguments provided to two when selected
type FooTwoFieldResolverArgs struct {
	Argument *InputType // Argument - self descriptive
}

// FooTwoFieldResolverParams contains contextual info to resolve two field
type FooTwoFieldResolverParams struct {
	graphql.ResolveParams
	FooTwoFieldResolverArgs
}

// FooTwoFieldResolver implement to resolve requests for the Foo's two field.
type FooTwoFieldResolver interface {
	// Two implements response to request for two field.
	Two(p FooTwoFieldResolverParams) (interface{}, error)
}

// FooThreeFieldResolverArgs contains arguments provided to three when selected
type FooThreeFieldResolverArgs struct {
	Argument *InputType // Argument - self descriptive
	Other    string     // Other - self descriptive
}

// FooThreeFieldResolverParams contains contextual info to resolve three field
type FooThreeFieldResolverParams struct {
	graphql.ResolveParams
	FooThreeFieldResolverArgs
}

// FooThreeFieldResolver implement to resolve requests for the Foo's three field.
type FooThreeFieldResolver interface {
	// Three implements response to request for three field.
	Three(p FooThreeFieldResolverParams) (int, error)
}

// FooFourFieldResolverArgs contains arguments provided to four when selected
type FooFourFieldResolverArgs struct {
	Argument string // Argument - self descriptive
}

// FooFourFieldResolverParams contains contextual info to resolve four field
type FooFourFieldResolverParams struct {
	graphql.ResolveParams
	FooFourFieldResolverArgs
}

// FooFourFieldResolver implement to resolve requests for the Foo's four field.
type FooFourFieldResolver interface {
	// Four implements response to request for four field.
	Four(p FooFourFieldResolverParams) (string, error)
}

// FooFiveFieldResolverArgs contains arguments provided to five when selected
type FooFiveFieldResolverArgs struct {
	Argument []string // Argument - self descriptive
}

// FooFiveFieldResolverParams contains contextual info to resolve five field
type FooFiveFieldResolverParams struct {
	graphql.ResolveParams
	FooFiveFieldResolverArgs
}

// FooFiveFieldResolver implement to resolve requests for the Foo's five field.
type FooFiveFieldResolver interface {
	// Five implements response to request for five field.
	Five(p FooFiveFieldResolverParams) (string, error)
}

// FooSixFieldResolverArgs contains arguments provided to six when selected
type FooSixFieldResolverArgs struct {
	Argument *InputType // Argument - self descriptive
}

// FooSixFieldResolverParams contains contextual info to resolve six field
type FooSixFieldResolverParams struct {
	graphql.ResolveParams
	FooSixFieldResolverArgs
}

// FooSixFieldResolver implement to resolve requests for the Foo's six field.
type FooSixFieldResolver interface {
	// Six implements response to request for six field.
	Six(p FooSixFieldResolverParams) (interface{}, error)
}

// FooSevenFieldResolver implement to resolve requests for the Foo's seven field.
type FooSevenFieldResolver interface {
	// Seven implements response to request for seven field.
	Seven(p graphql.ResolveParams) (interface{}, error)
}

//
// FooFieldResolvers represents a collection of methods whose products represent the
// response values of the 'Foo' type.
//
// == Example SDL
//
//   """
//   Dog's are not hooman.
//   """
//   type Dog implements Pet {
//     "name of this fine beast."
//     name:  String!
//
//     "breed of this silly animal; probably shibe."
//     breed: [Breed]
//   }
//
// == Example generated interface
//
//   // DogResolver ...
//   type DogFieldResolvers interface {
//     DogNameFieldResolver
//     DogBreedFieldResolver
//
//     // IsTypeOf is used to determine if a given value is associated with the Dog type
//     IsTypeOf(interface{}, graphql.IsTypeOfParams) bool
//   }
//
// == Example implementation ...
//
//   // DogResolver implements DogFieldResolvers interface
//   type DogResolver struct {
//     logger logrus.LogEntry
//     store interface{
//       store.BreedStore
//       store.DogStore
//     }
//   }
//
//   // Name implements response to request for name field.
//   func (r *DogResolver) Name(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     return dog.GetName()
//   }
//
//   // Breed implements response to request for breed field.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     breed := r.store.GetBreed(dog.GetBreedName())
//     return breed
//   }
//
//   // IsTypeOf is used to determine if a given value is associated with the Dog type
//   func (r *DogResolver) IsTypeOf(p graphql.IsTypeOfParams) bool {
//     // ... implementation details ...
//     _, ok := p.Value.(DogGetter)
//     return ok
//   }
//
type FooFieldResolvers interface {
	FooOneFieldResolver
	FooTwoFieldResolver
	FooThreeFieldResolver
	FooFourFieldResolver
	FooFiveFieldResolver
	FooSixFieldResolver
	FooSevenFieldResolver

	// IsTypeOf is used to determine if a given value is associated with the Foo type
	IsTypeOf(interface{}, graphql.IsTypeOfParams) bool
}

// FooAliases implements all methods on FooFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
//
// == Example SDL
//
//    type Dog {
//      name:   String!
//      weight: Float!
//      dob:    DateTime
//      breed:  [Breed]
//    }
//
// == Example generated aliases
//
//   type DogAliases struct {}
//   func (_ DogAliases) Name(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Weight(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Dob(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//
// == Example Implementation
//
//   type DogResolver struct { // Implements DogResolver
//     DogAliases
//     store store.BreedStore
//   }
//
//   // NOTE:
//   // All other fields are satisified by DogAliases but since this one
//   // requires hitting the store we implement it in our resolver.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) interface{} {
//     dog := v.(*Dog)
//     return r.BreedsById(dog.BreedIDs)
//   }
//
type FooAliases struct{}

// One implements response to request for 'one' field.
func (_ FooAliases) One(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret := val.(interface{})
	return ret, err
}

// Two implements response to request for 'two' field.
func (_ FooAliases) Two(p FooTwoFieldResolverParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret := val.(interface{})
	return ret, err
}

// Three implements response to request for 'three' field.
func (_ FooAliases) Three(p FooThreeFieldResolverParams) (int, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret := val.(int)
	return ret, err
}

// Four implements response to request for 'four' field.
func (_ FooAliases) Four(p FooFourFieldResolverParams) (string, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret := val.(string)
	return ret, err
}

// Five implements response to request for 'five' field.
func (_ FooAliases) Five(p FooFiveFieldResolverParams) (string, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret := val.(string)
	return ret, err
}

// Six implements response to request for 'six' field.
func (_ FooAliases) Six(p FooSixFieldResolverParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret := val.(interface{})
	return ret, err
}

// Seven implements response to request for 'seven' field.
func (_ FooAliases) Seven(p graphql.ResolveParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret := val.(interface{})
	return ret, err
}

// FooType Foo is quite the type.
var FooType = graphql.NewType("Foo", graphql.ObjectKind)

// RegisterFoo registers Foo object type with given service.
func RegisterFoo(svc *graphql.Service, impl FooFieldResolvers) {
	svc.RegisterObject(_ObjectTypeFooDesc, impl)
}
func _ObjTypeFooOneHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(FooOneFieldResolver)
	return resolver.One
}

func _ObjTypeFooTwoHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(FooTwoFieldResolver)
	return func(p graphql1.ResolveParams) (interface{}, error) {
		frp := FooTwoFieldResolverParams{ResolveParams: p}
		err := mapstructure.Decode(p.Args, &frp.Args)
		if err != nil {
			return nil, err
		}

		return resolver.Two(frp)
	}
}

func _ObjTypeFooThreeHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(FooThreeFieldResolver)
	return func(p graphql1.ResolveParams) (interface{}, error) {
		frp := FooThreeFieldResolverParams{ResolveParams: p}
		err := mapstructure.Decode(p.Args, &frp.Args)
		if err != nil {
			return nil, err
		}

		return resolver.Three(frp)
	}
}

func _ObjTypeFooFourHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(FooFourFieldResolver)
	return func(p graphql1.ResolveParams) (interface{}, error) {
		frp := FooFourFieldResolverParams{ResolveParams: p}
		err := mapstructure.Decode(p.Args, &frp.Args)
		if err != nil {
			return nil, err
		}

		return resolver.Four(frp)
	}
}

func _ObjTypeFooFiveHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(FooFiveFieldResolver)
	return func(p graphql1.ResolveParams) (interface{}, error) {
		frp := FooFiveFieldResolverParams{ResolveParams: p}
		err := mapstructure.Decode(p.Args, &frp.Args)
		if err != nil {
			return nil, err
		}

		return resolver.Five(frp)
	}
}

func _ObjTypeFooSixHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(FooSixFieldResolver)
	return func(p graphql1.ResolveParams) (interface{}, error) {
		frp := FooSixFieldResolverParams{ResolveParams: p}
		err := mapstructure.Decode(p.Args, &frp.Args)
		if err != nil {
			return nil, err
		}

		return resolver.Six(frp)
	}
}

func _ObjTypeFooSevenHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(FooSevenFieldResolver)
	return resolver.Seven
}

func _ObjectTypeFooConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "Foo is quite the type.",
		Fields: graphql1.Fields{
			"five": &graphql1.Field{
				Args: graphql1.FieldConfigArgument{"argument": &graphql1.ArgumentConfig{
					DefaultValue: []interface{}{"string", "string"},
					Description:  "self descriptive",
					Type:         graphql1.NewList(graphql1.String),
				}},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "five",
				Type:              graphql1.String,
			},
			"four": &graphql1.Field{
				Args: graphql1.FieldConfigArgument{"argument": &graphql1.ArgumentConfig{
					DefaultValue: "string",
					Description:  "self descriptive",
					Type:         graphql1.String,
				}},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "four",
				Type:              graphql1.String,
			},
			"one": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "one is a number.",
				Name:              "one",
				Type:              graphql.OutputType("Url"),
			},
			"seven": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "seven",
				Type:              graphql1.NewList(graphql.OutputType("Bar")),
			},
			"six": &graphql1.Field{
				Args: graphql1.FieldConfigArgument{"argument": &graphql1.ArgumentConfig{
					DefaultValue: map[string]interface{}{"key": "value"},
					Description:  "self descriptive",
					Type:         graphql.InputType("InputType"),
				}},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "six",
				Type:              graphql.OutputType("Url"),
			},
			"three": &graphql1.Field{
				Args: graphql1.FieldConfigArgument{
					"argument": &graphql1.ArgumentConfig{
						Description: "self descriptive",
						Type:        graphql.InputType("InputType"),
					},
					"other": &graphql1.ArgumentConfig{
						Description: "self descriptive",
						Type:        graphql1.String,
					},
				},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "three",
				Type:              graphql1.Int,
			},
			"two": &graphql1.Field{
				Args: graphql1.FieldConfigArgument{"argument": &graphql1.ArgumentConfig{
					Description: "self descriptive",
					Type:        graphql1.NewNonNull(graphql.InputType("InputType")),
				}},
				DeprecationReason: "",
				Description:       "I am told that two is also a number",
				Name:              "two",
				Type:              graphql.OutputType("Url"),
			},
		},
		Interfaces: []*graphql1.Interface{
			graphql.Interface("Bar")},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see FooFieldResolvers.")
		},
		Name: "Foo",
	}
}

// describe Foo's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeFooDesc = graphql.ObjectDesc{
	Config: _ObjectTypeFooConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{
		"five":  _ObjTypeFooFiveHandler,
		"four":  _ObjTypeFooFourHandler,
		"one":   _ObjTypeFooOneHandler,
		"seven": _ObjTypeFooSevenHandler,
		"six":   _ObjTypeFooSixHandler,
		"three": _ObjTypeFooThreeHandler,
		"two":   _ObjTypeFooTwoHandler,
	},
}

// AnnotatedObjectAnnotatedFieldFieldResolverArgs contains arguments provided to annotatedField when selected
type AnnotatedObjectAnnotatedFieldFieldResolverArgs struct {
	Arg interface{} // Arg - self descriptive
}

// AnnotatedObjectAnnotatedFieldFieldResolverParams contains contextual info to resolve annotatedField field
type AnnotatedObjectAnnotatedFieldFieldResolverParams struct {
	graphql.ResolveParams
	AnnotatedObjectAnnotatedFieldFieldResolverArgs
}

// AnnotatedObjectAnnotatedFieldFieldResolver implement to resolve requests for the AnnotatedObject's annotatedField field.
type AnnotatedObjectAnnotatedFieldFieldResolver interface {
	// AnnotatedField implements response to request for annotatedField field.
	AnnotatedField(p AnnotatedObjectAnnotatedFieldFieldResolverParams) (interface{}, error)
}

//
// AnnotatedObjectFieldResolvers represents a collection of methods whose products represent the
// response values of the 'AnnotatedObject' type.
//
// == Example SDL
//
//   """
//   Dog's are not hooman.
//   """
//   type Dog implements Pet {
//     "name of this fine beast."
//     name:  String!
//
//     "breed of this silly animal; probably shibe."
//     breed: [Breed]
//   }
//
// == Example generated interface
//
//   // DogResolver ...
//   type DogFieldResolvers interface {
//     DogNameFieldResolver
//     DogBreedFieldResolver
//
//     // IsTypeOf is used to determine if a given value is associated with the Dog type
//     IsTypeOf(interface{}, graphql.IsTypeOfParams) bool
//   }
//
// == Example implementation ...
//
//   // DogResolver implements DogFieldResolvers interface
//   type DogResolver struct {
//     logger logrus.LogEntry
//     store interface{
//       store.BreedStore
//       store.DogStore
//     }
//   }
//
//   // Name implements response to request for name field.
//   func (r *DogResolver) Name(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     return dog.GetName()
//   }
//
//   // Breed implements response to request for breed field.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     breed := r.store.GetBreed(dog.GetBreedName())
//     return breed
//   }
//
//   // IsTypeOf is used to determine if a given value is associated with the Dog type
//   func (r *DogResolver) IsTypeOf(p graphql.IsTypeOfParams) bool {
//     // ... implementation details ...
//     _, ok := p.Value.(DogGetter)
//     return ok
//   }
//
type AnnotatedObjectFieldResolvers interface {
	AnnotatedObjectAnnotatedFieldFieldResolver

	// IsTypeOf is used to determine if a given value is associated with the AnnotatedObject type
	IsTypeOf(interface{}, graphql.IsTypeOfParams) bool
}

// AnnotatedObjectAliases implements all methods on AnnotatedObjectFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
//
// == Example SDL
//
//    type Dog {
//      name:   String!
//      weight: Float!
//      dob:    DateTime
//      breed:  [Breed]
//    }
//
// == Example generated aliases
//
//   type DogAliases struct {}
//   func (_ DogAliases) Name(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Weight(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Dob(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//
// == Example Implementation
//
//   type DogResolver struct { // Implements DogResolver
//     DogAliases
//     store store.BreedStore
//   }
//
//   // NOTE:
//   // All other fields are satisified by DogAliases but since this one
//   // requires hitting the store we implement it in our resolver.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) interface{} {
//     dog := v.(*Dog)
//     return r.BreedsById(dog.BreedIDs)
//   }
//
type AnnotatedObjectAliases struct{}

// AnnotatedField implements response to request for 'annotatedField' field.
func (_ AnnotatedObjectAliases) AnnotatedField(p AnnotatedObjectAnnotatedFieldFieldResolverParams) (interface{}, error) {
	val, err := graphql.DefaultResolver(p.Source, p.Info.FieldName)
	ret := val.(interface{})
	return ret, err
}

// AnnotatedObjectType self descriptive
var AnnotatedObjectType = graphql.NewType("AnnotatedObject", graphql.ObjectKind)

// RegisterAnnotatedObject registers AnnotatedObject object type with given service.
func RegisterAnnotatedObject(svc *graphql.Service, impl AnnotatedObjectFieldResolvers) {
	svc.RegisterObject(_ObjectTypeAnnotatedObjectDesc, impl)
}
func _ObjTypeAnnotatedObjectAnnotatedFieldHandler(impl interface{}) graphql1.FieldResolveFn {
	resolver := impl.(AnnotatedObjectAnnotatedFieldFieldResolver)
	return func(p graphql1.ResolveParams) (interface{}, error) {
		frp := AnnotatedObjectAnnotatedFieldFieldResolverParams{ResolveParams: p}
		err := mapstructure.Decode(p.Args, &frp.Args)
		if err != nil {
			return nil, err
		}

		return resolver.AnnotatedField(frp)
	}
}

func _ObjectTypeAnnotatedObjectConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{"annotatedField": &graphql1.Field{
			Args: graphql1.FieldConfigArgument{"arg": &graphql1.ArgumentConfig{
				DefaultValue: "default",
				Description:  "self descriptive",
				Type:         graphql.InputType("Url"),
			}},
			DeprecationReason: "",
			Description:       "self descriptive",
			Name:              "annotatedField",
			Type:              graphql.OutputType("Url"),
		}},
		Interfaces: []*graphql1.Interface{},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see AnnotatedObjectFieldResolvers.")
		},
		Name: "AnnotatedObject",
	}
}

// describe AnnotatedObject's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeAnnotatedObjectDesc = graphql.ObjectDesc{
	Config:        _ObjectTypeAnnotatedObjectConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{"annotatedField": _ObjTypeAnnotatedObjectAnnotatedFieldHandler},
}

// BarType self descriptive
var BarType = graphql.NewType("Bar", graphql.InterfaceKind)

// RegisterBar registers Bar object type with given service.
func RegisterBar(svc *graphql.Service, impl graphql.InterfaceTypeResolver) {
	svc.RegisterInterface(_InterfaceTypeBarDesc, impl)
}
func _InterfaceTypeBarConfigFn() graphql1.InterfaceConfig {
	return graphql1.InterfaceConfig{
		Description: "self descriptive",
		Fields: graphql1.Fields{
			"four": &graphql1.Field{
				Args: graphql1.FieldConfigArgument{"argument": &graphql1.ArgumentConfig{
					DefaultValue: "string",
					Description:  "self descriptive",
					Type:         graphql1.String,
				}},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "four",
				Type:              graphql1.String,
			},
			"one": &graphql1.Field{
				Args:              graphql1.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "one",
				Type:              graphql.OutputType("Url"),
			},
		},
		Name: "Bar",
		ResolveType: func(_ graphql1.ResolveTypeParams) *graphql1.Object {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see InterfaceTypeResolver.")
		},
	}
}

// describe Bar's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _InterfaceTypeBarDesc = graphql.InterfaceDesc{Config: _InterfaceTypeBarConfigFn}

// AnnotatedInterfaceType AnnotatedInterface has stuff
var AnnotatedInterfaceType = graphql.NewType("AnnotatedInterface", graphql.InterfaceKind)

// RegisterAnnotatedInterface registers AnnotatedInterface object type with given service.
func RegisterAnnotatedInterface(svc *graphql.Service, impl graphql.InterfaceTypeResolver) {
	svc.RegisterInterface(_InterfaceTypeAnnotatedInterfaceDesc, impl)
}
func _InterfaceTypeAnnotatedInterfaceConfigFn() graphql1.InterfaceConfig {
	return graphql1.InterfaceConfig{
		Description: "AnnotatedInterface has stuff",
		Fields: graphql1.Fields{"annotatedField": &graphql1.Field{
			Args: graphql1.FieldConfigArgument{"arg": &graphql1.ArgumentConfig{
				Description: "self descriptive",
				Type:        graphql.InputType("Url"),
			}},
			DeprecationReason: "",
			Description:       "self descriptive",
			Name:              "annotatedField",
			Type:              graphql.OutputType("Url"),
		}},
		Name: "AnnotatedInterface",
		ResolveType: func(_ graphql1.ResolveTypeParams) *graphql1.Object {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see InterfaceTypeResolver.")
		},
	}
}

// describe AnnotatedInterface's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _InterfaceTypeAnnotatedInterfaceDesc = graphql.InterfaceDesc{Config: _InterfaceTypeAnnotatedInterfaceConfigFn}

// FeedType Feed includes all stuff and things.
var FeedType = graphql.NewType("Feed", graphql.UnionKind)

// RegisterFeed registers Feed object type with given service.
func RegisterFeed(svc *graphql.Service, impl graphql.UnionTypeResolver) {
	svc.RegisterUnion(_UnionTypeFeedDesc, impl)
}
func _UnionTypeFeedConfigFn() graphql1.UnionConfig {
	return graphql1.UnionConfig{
		Description: "Feed includes all stuff and things.",
		Name:        "Feed",
		ResolveType: func(_ graphql1.ResolveTypeParams) *graphql1.Object {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see UnionTypeResolver.")
		},
		Types: []*graphql1.Object{
			graphql.Object("Foo"),
			graphql.Object("QueryRoot")},
	}
}

// describe Feed's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _UnionTypeFeedDesc = graphql.UnionDesc{Config: _UnionTypeFeedConfigFn}

// AnnotatedUnionType AnnotatedUnion i dont care
var AnnotatedUnionType = graphql.NewType("AnnotatedUnion", graphql.UnionKind)

// RegisterAnnotatedUnion registers AnnotatedUnion object type with given service.
func RegisterAnnotatedUnion(svc *graphql.Service, impl graphql.UnionTypeResolver) {
	svc.RegisterUnion(_UnionTypeAnnotatedUnionDesc, impl)
}
func _UnionTypeAnnotatedUnionConfigFn() graphql1.UnionConfig {
	return graphql1.UnionConfig{
		Description: "AnnotatedUnion i dont care",
		Name:        "AnnotatedUnion",
		ResolveType: func(_ graphql1.ResolveTypeParams) *graphql1.Object {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see UnionTypeResolver.")
		},
		Types: []*graphql1.Object{
			graphql.Object("A"),
			graphql.Object("B")},
	}
}

// describe AnnotatedUnion's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _UnionTypeAnnotatedUnionDesc = graphql.UnionDesc{Config: _UnionTypeAnnotatedUnionConfigFn}

// CustomScalarType ... CustomScalar self descriptive
var CustomScalarType = graphql.NewType("CustomScalar", graphql.ScalarKind)

// RegisterCustomScalar registers CustomScalar object type with given service.
func RegisterCustomScalar(svc *graphql.Service, impl graphql.ScalarResolver) {
	svc.RegisterScalar(_ScalarTypeCustomScalarDesc, impl)
}

// describe CustomScalar's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ScalarTypeCustomScalarDesc = graphql.ScalarDesc{Config: func() graphql1.ScalarConfig {
	return graphql1.ScalarConfig{
		Description: "self descriptive",
		Name:        "CustomScalar",
		ParseLiteral: func(_ ast.Value) interface{} {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see ScalarResolver.")
		},
		ParseValue: func(_ interface{}) interface{} {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see ScalarResolver.")
		},
		Serialize: func(_ interface{}) interface{} {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see ScalarResolver.")
		},
	}
}}

// AnnotatedScalarType ... AnnotatedScalar self descriptive
var AnnotatedScalarType = graphql.NewType("AnnotatedScalar", graphql.ScalarKind)

// RegisterAnnotatedScalar registers AnnotatedScalar object type with given service.
func RegisterAnnotatedScalar(svc *graphql.Service, impl graphql.ScalarResolver) {
	svc.RegisterScalar(_ScalarTypeAnnotatedScalarDesc, impl)
}

// describe AnnotatedScalar's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ScalarTypeAnnotatedScalarDesc = graphql.ScalarDesc{Config: func() graphql1.ScalarConfig {
	return graphql1.ScalarConfig{
		Description: "self descriptive",
		Name:        "AnnotatedScalar",
		ParseLiteral: func(_ ast.Value) interface{} {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see ScalarResolver.")
		},
		ParseValue: func(_ interface{}) interface{} {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see ScalarResolver.")
		},
		Serialize: func(_ interface{}) interface{} {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see ScalarResolver.")
		},
	}
}}

// Site self descriptive
type Site string

// Sites holds enum values
var Sites = _EnumTypeSiteValues{
	DESKTOP: "DESKTOP",
	MOBILE:  "MOBILE",
}

// SiteType self descriptive
var SiteType = graphql.NewType("Site", graphql.EnumKind)

// RegisterSite registers Site object type with given service.
func RegisterSite(svc *graphql.Service) {
	svc.RegisterEnum(_EnumTypeSiteDesc)
}
func _EnumTypeSiteConfigFn() graphql1.EnumConfig {
	return graphql1.EnumConfig{
		Description: "self descriptive",
		Name:        "Site",
		Values: graphql1.EnumValueConfigMap{
			"DESKTOP": &graphql1.EnumValueConfig{
				DeprecationReason: "",
				Description:       "self descriptive",
				Value:             "DESKTOP",
			},
			"MOBILE": &graphql1.EnumValueConfig{
				DeprecationReason: "",
				Description:       "self descriptive",
				Value:             "MOBILE",
			},
		},
	}
}

// describe Site's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _EnumTypeSiteDesc = graphql.EnumDesc{Config: _EnumTypeSiteConfigFn}

type _EnumTypeSiteValues struct {
	// DESKTOP - self descriptive
	DESKTOP string
	// MOBILE - self descriptive
	MOBILE string
}

// Locale self descriptive
type Locale string

// Locales holds enum values
var Locales = _EnumTypeLocaleValues{
	EN: "EN",
	HI: "HI",
	JA: "JA",
	LA: "LA",
}

// LocaleType self descriptive
var LocaleType = graphql.NewType("Locale", graphql.EnumKind)

// RegisterLocale registers Locale object type with given service.
func RegisterLocale(svc *graphql.Service) {
	svc.RegisterEnum(_EnumTypeLocaleDesc)
}
func _EnumTypeLocaleConfigFn() graphql1.EnumConfig {
	return graphql1.EnumConfig{
		Description: "self descriptive",
		Name:        "Locale",
		Values: graphql1.EnumValueConfigMap{
			"EN": &graphql1.EnumValueConfig{
				DeprecationReason: "",
				Description:       "Language I know",
				Value:             "EN",
			},
			"HI": &graphql1.EnumValueConfig{
				DeprecationReason: "",
				Description:       "India",
				Value:             "HI",
			},
			"JA": &graphql1.EnumValueConfig{
				DeprecationReason: "",
				Description:       "Glorious nippon",
				Value:             "JA",
			},
			"LA": &graphql1.EnumValueConfig{
				DeprecationReason: "dead language",
				Description:       "Lanugage I don't know",
				Value:             "LA",
			},
		},
	}
}

// describe Locale's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _EnumTypeLocaleDesc = graphql.EnumDesc{Config: _EnumTypeLocaleConfigFn}

type _EnumTypeLocaleValues struct {
	// EN - Language I know
	EN string
	// JA - Glorious nippon
	JA string
	// HI - India
	HI string
	// LA - Lanugage I don't know
	LA string
}

// AnnotatedEnum self descriptive
type AnnotatedEnum string

// AnnotatedEnums holds enum values
var AnnotatedEnums = _EnumTypeAnnotatedEnumValues{
	ANNOTATED_VALUE: "ANNOTATED_VALUE",
	OTHER_VALUE:     "OTHER_VALUE",
}

// AnnotatedEnumType self descriptive
var AnnotatedEnumType = graphql.NewType("AnnotatedEnum", graphql.EnumKind)

// RegisterAnnotatedEnum registers AnnotatedEnum object type with given service.
func RegisterAnnotatedEnum(svc *graphql.Service) {
	svc.RegisterEnum(_EnumTypeAnnotatedEnumDesc)
}
func _EnumTypeAnnotatedEnumConfigFn() graphql1.EnumConfig {
	return graphql1.EnumConfig{
		Description: "self descriptive",
		Name:        "AnnotatedEnum",
		Values: graphql1.EnumValueConfigMap{
			"ANNOTATED_VALUE": &graphql1.EnumValueConfig{
				DeprecationReason: "",
				Description:       "self descriptive",
				Value:             "ANNOTATED_VALUE",
			},
			"OTHER_VALUE": &graphql1.EnumValueConfig{
				DeprecationReason: "",
				Description:       "self descriptive",
				Value:             "OTHER_VALUE",
			},
		},
	}
}

// describe AnnotatedEnum's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _EnumTypeAnnotatedEnumDesc = graphql.EnumDesc{Config: _EnumTypeAnnotatedEnumConfigFn}

type _EnumTypeAnnotatedEnumValues struct {
	// ANNOTATED_VALUE - self descriptive
	ANNOTATED_VALUE string
	// OTHER_VALUE - self descriptive
	OTHER_VALUE string
}

// InputType is neato
type InputType struct {
	// Key - self descriptive Key string
	// Answer - self descriptive Answer int
	/*
	   Answr - self descriptive

	   Deprecated: No longer supported
	*/Answr int
}

// InputTypeType InputType is neato
var InputTypeType = graphql.NewType("InputType", graphql.InputKind)

// RegisterInputType registers InputType object type with given service.
func RegisterInputType(svc *graphql.Service) {
	svc.RegisterInput(_InputTypeInputTypeDesc)
}
func _InputTypeInputTypeConfigFn() graphql1.InputObjectConfig {
	return graphql1.InputObjectConfig{
		Description: "InputType is neato",
		Fields: graphql1.InputObjectConfigFieldMap{
			"answer": &graphql1.InputObjectFieldConfig{
				DefaultValue: "42",
				Description:  "self descriptive",
				Type:         graphql1.Int,
			},
			"answr": &graphql1.InputObjectFieldConfig{
				DefaultValue: "42",
				Description:  "self descriptive",
				Type:         graphql1.Int,
			},
			"key": &graphql1.InputObjectFieldConfig{
				Description: "self descriptive",
				Type:        graphql1.NewNonNull(graphql1.String),
			},
		},
		Name: "InputType",
	}
}

// describe InputType's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _InputTypeInputTypeDesc = graphql.InputDesc{Config: _InputTypeInputTypeConfigFn}

// AnnotatedInput self descriptive
type AnnotatedInput struct {
	// AnnotatedField - self descriptive AnnotatedField interface{}
}

// AnnotatedInputType self descriptive
var AnnotatedInputType = graphql.NewType("AnnotatedInput", graphql.InputKind)

// RegisterAnnotatedInput registers AnnotatedInput object type with given service.
func RegisterAnnotatedInput(svc *graphql.Service) {
	svc.RegisterInput(_InputTypeAnnotatedInputDesc)
}
func _InputTypeAnnotatedInputConfigFn() graphql1.InputObjectConfig {
	return graphql1.InputObjectConfig{
		Description: "self descriptive",
		Fields: graphql1.InputObjectConfigFieldMap{"annotatedField": &graphql1.InputObjectFieldConfig{
			Description: "self descriptive",
			Type:        graphql.InputType("Url"),
		}},
		Name: "AnnotatedInput",
	}
}

// describe AnnotatedInput's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _InputTypeAnnotatedInputDesc = graphql.InputDesc{Config: _InputTypeAnnotatedInputConfigFn}

//
// NoFieldsFieldResolvers represents a collection of methods whose products represent the
// response values of the 'NoFields' type.
//
// == Example SDL
//
//   """
//   Dog's are not hooman.
//   """
//   type Dog implements Pet {
//     "name of this fine beast."
//     name:  String!
//
//     "breed of this silly animal; probably shibe."
//     breed: [Breed]
//   }
//
// == Example generated interface
//
//   // DogResolver ...
//   type DogFieldResolvers interface {
//     DogNameFieldResolver
//     DogBreedFieldResolver
//
//     // IsTypeOf is used to determine if a given value is associated with the Dog type
//     IsTypeOf(interface{}, graphql.IsTypeOfParams) bool
//   }
//
// == Example implementation ...
//
//   // DogResolver implements DogFieldResolvers interface
//   type DogResolver struct {
//     logger logrus.LogEntry
//     store interface{
//       store.BreedStore
//       store.DogStore
//     }
//   }
//
//   // Name implements response to request for name field.
//   func (r *DogResolver) Name(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     return dog.GetName()
//   }
//
//   // Breed implements response to request for breed field.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // ... implementation details ...
//     dog := p.Source.(DogGetter)
//     breed := r.store.GetBreed(dog.GetBreedName())
//     return breed
//   }
//
//   // IsTypeOf is used to determine if a given value is associated with the Dog type
//   func (r *DogResolver) IsTypeOf(p graphql.IsTypeOfParams) bool {
//     // ... implementation details ...
//     _, ok := p.Value.(DogGetter)
//     return ok
//   }
//
type NoFieldsFieldResolvers interface {

	// IsTypeOf is used to determine if a given value is associated with the NoFields type
	IsTypeOf(interface{}, graphql.IsTypeOfParams) bool
}

// NoFieldsAliases implements all methods on NoFieldsFieldResolvers interface by using reflection to
// match name of field to a field on the given value. Intent is reduce friction
// of writing new resolvers by removing all the instances where you would simply
// have the resolvers method return a field.
//
// == Example SDL
//
//    type Dog {
//      name:   String!
//      weight: Float!
//      dob:    DateTime
//      breed:  [Breed]
//    }
//
// == Example generated aliases
//
//   type DogAliases struct {}
//   func (_ DogAliases) Name(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Weight(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Dob(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//   func (_ DogAliases) Breed(p graphql.ResolveParams) (interface{}, error) {
//     // reflect...
//   }
//
// == Example Implementation
//
//   type DogResolver struct { // Implements DogResolver
//     DogAliases
//     store store.BreedStore
//   }
//
//   // NOTE:
//   // All other fields are satisified by DogAliases but since this one
//   // requires hitting the store we implement it in our resolver.
//   func (r *DogResolver) Breed(p graphql.ResolveParams) interface{} {
//     dog := v.(*Dog)
//     return r.BreedsById(dog.BreedIDs)
//   }
//
type NoFieldsAliases struct{}

// NoFieldsType self descriptive
var NoFieldsType = graphql.NewType("NoFields", graphql.ObjectKind)

// RegisterNoFields registers NoFields object type with given service.
func RegisterNoFields(svc *graphql.Service, impl NoFieldsFieldResolvers) {
	svc.RegisterObject(_ObjectTypeNoFieldsDesc, impl)
}
func _ObjectTypeNoFieldsConfigFn() graphql1.ObjectConfig {
	return graphql1.ObjectConfig{
		Description: "self descriptive",
		Fields:      graphql1.Fields{},
		Interfaces:  []*graphql1.Interface{},
		IsTypeOf: func(_ graphql1.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see NoFieldsFieldResolvers.")
		},
		Name: "NoFields",
	}
}

// describe NoFields's configuration; kept private to avoid unintentional tampering of configuration at runtime.
var _ObjectTypeNoFieldsDesc = graphql.ObjectDesc{
	Config:        _ObjectTypeNoFieldsConfigFn,
	FieldHandlers: map[string]graphql.FieldHandler{},
}
